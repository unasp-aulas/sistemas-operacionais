---
title: "Sistemas Operacionais"
author: "Thiago Pires"
title-slide-attributes:
  data-background-image: cover.gif
  data-background-position: cover
format: 
  revealjs:
    theme: theme.scss
    width: 1600
    height: 900
    footer: "[github.com/unasp-aulas/sistemas-operacionais](https://github.com/unasp-aulas/sistemas-operacionais)"
html-math-method: mathjax
code-annotations: below
self-contained: true
---

# Fundamentos de Sistemas Operacionais

\

> [A função do [sistema operacional]{.blue} é fornecer aos programas do usuário um modelo do computador melhor]{.marked}, mais simples e mais limpo, assim como lidar com o gerenciamento de todos os recursos mencionados. *A maioria dos computadores tem dois modos de operação: [modo núcleo e modo usuário.]{.blue}*

## Fundamentos de Sistemas Operacionais

:::: columns
::: {.column width="40%"}

\

O sistema operacional opera em [modo núcleo]{.blue} (também chamado modo supervisor). Nesse modo, [ele tem acesso completo a todo o hardware e *pode executar qualquer instrução]{.marked} que a máquina for capaz de executar.*
:::
::: {.column width="60%"}

\

Observe, na figura a seguir, uma visão geral simplificada dos [principais componentes]{.blue}:

![](images/tanenbaum-01-01.png)
:::
::::

## Fundamentos de Sistemas Operacionais

\

:::: columns
::: {.column width="33%" .fragment fragment-index=1}
O resto do software opera em [modo usuário]{.blue}, no qual apenas um subconjunto das instruções da máquina está disponível.
:::
::: {.column width="33%" .fragment fragment-index=2}
A diferença entre os [modos]{.blue} exerce papel crucial na maneira como os sistemas operacionais funcionam.
:::
::: {.column width="33%" .fragment fragment-index=3}
[Os sistemas operacionais são enormes, complexos]{.marked} e têm vida longa. O código-fonte do coração de um sistema operacional como Linux ou Windows tem cerca de cinco milhões de linhas.
:::
::::

## O que é um sistema operacional?

\

> *Os sistemas operacionais realizam [duas funções essencialmente não relacionadas]{.marked}: [(1) fornecer a programadores de aplicativos (e programas aplicativos, claro) um conjunto de recursos abstratos limpo em vez de recursos confusos de hardware, e]{.fragment fragment-index=2  .semi-fade-out} [(2) gerenciar esses recursos de hardware]{.fragment fragment-index=2}*

## O que é um sistema operacional? 

\

:::: columns
::: {.column width="30%"}
> *Sistemas operacionais transformam o [feio em belo]{.marked}, como mostrado na figura:*
:::
::: {.column width="70%"}
![](images/tanenbaum-01-02.png){width="80%"}
:::
::::

[Usando essa [abstração]{.blue}, os programas podem criar, escrever, ler arquivos, sem ter que lidar com detalhes complexos de como o hardware funciona]{.fragment}

## O que é um sistema operacional? 

\

> *[O conceito de um sistema operacional como fundamentalmente [fornecendo abstrações]{.marked} para programas aplicativos é uma visão top-down (abstração de cima para baixo).]{.fragment fragment-index=2 .semi-fade-out} [Uma visão alternativa, bottom-up (abstração de baixo para cima), sustenta que o sistema operacional está ali para [gerenciar todas as partes de um sistema complexo]{.marked}.]{.fragment fragment-index=2}*

## O que é um sistema operacional? 

\

:::: columns
::: {.column width="30%"}
O gerenciamento de recursos inclui a [multiplexação]{.blue} (compartilhamento) de recursos de duas maneiras diferentes: [no tempo e no espaço]{.marked}. 
:::
::: {.column width="70%"}
::: {.fragment fragment-index=2 .semi-fade-out}
- Quando um recurso é [multiplexado no tempo]{.marked}, diferentes programas ou usuários se revezam usando-o.
:::
::: {.fragment fragment-index=2}
- O outro tipo é a [multiplexação de espaço]{.marked}. Em vez de os clientes se revezarem, cada um tem direito a uma parte do recurso.
:::
:::
::::

## O que é um sistema operacional? 

\

1. *Quando múltiplas saídas de impressão estão na fila para serem impressas em uma única impressora, uma decisão tem de ser tomada sobre qual deve ser impressa em seguida.*

::: {.fragment}
 [Multiplexado no tempo]{.blue}
:::

2. *Em vez de os clientes se revezarem, cada um tem direito a uma parte do recurso. Por exemplo, a memória principal é normalmente dividida entre vários programas sendo executados, de modo que cada um pode ser residente ao mesmo tempo (por exemplo, a fim de se revezar usando a CPU).*

::: {.fragment}
 [Multiplexado no espaço]{.blue}
:::

## Revisão sobre hardware de computadores

\

:::: columns
::: {.column width="30%"}
> *Um sistema operacional está intimamente ligado ao hardware do computador no qual ele é executado*
:::
::: {.column width="70%"}
![](images/tanenbaum-01-06.png)
:::
::::

\

A CPU, memória e dispositivos de E/S estão todos conectados por um [sistema de barramento (*bus*)]{.marked} e comunicam-se uns com os outros sobre ele.

## Revisão sobre hardware de computadores

\

### Processadores

> *O "cérebro" do computador é a CPU. O ciclo básico de toda CPU é buscar a primeira instrução da memória, decodificá-la para determinar o seu tipo e operandos, executá-la.*

\

:::: columns
::: {.column width="33%" .fragment}
[Cada CPU tem um conjunto específico de instruções]{.marked} que ela consegue executar. *Desse modo, um processador x86 não pode executar programas ARM.*

:::
::: {.column width="33%" .fragment}
As CPUs têm alguns
[registradores]{.blue} internos para armazenamento de variáveis
e resultados temporários.
:::
::: {.column width="33%" .fragment}
Os resgistradores são importantes por causa da [multiplexação de tempo da CPU.]{.marked}
:::
::::

## Revisão sobre hardware de computadores

\

:::: columns
::: {.column width="30%"}

### Memória 
> *É o segundo principal componente em qualquer computador, o qual deve ser rápido ao extremo (mais rápida do que executar uma instrução, de maneira que a CPU não seja atrasada pela memória).*
:::
::: {.column width="70%"}

\

![](images/tanenbaum-01-09.png)
:::
::::

## Memória

:::: {.columns}
::: {.column width="25%" .fragment}
A camada superior consiste em [registradores internos]{.blue} à CPU. Eles são feitos do mesmo material que a CPU e são, desse modo, tão rápidos quanto ela
:::
::: {.column width="25%" .fragment}
[Memória cache]{.blue} é uma parte da CPU. Atua como memória temporária para que seja recuperado rapidamente os dados, sem a necessidade de uma busca direta na memória principal
:::
::: {.column width="25%" .fragment}
[Mémoria principal]{.blue} tem por finalidade o armazenamento de instruções e dados de programas que serão ou estão sendo executados pela CPU.
:::
::: {.column width="25%" .fragment}
[Discos magnéticos]{.blue} são um tipo de memória não volátil de grande capacidade de armazenamento, usada para guardar informações (instruções e dados de programas) que não serão imediatamente usadas pela CPU.
:::
::::

## Exemplo de utilização de cache

\

:::: columns
::: {.column width="30%" .fragment}
[DuckDB]{.blue} tem uma forma de consulta (*vectorized or just-in-time query execution engines*) que [são processadas em lotes de dados que consistem em coleções de vetores]{.marked}, cada um contendo uma quantidade fixa de valores das colunas.
:::

::: {.column width="30%" .fragment}
O resultado é um uso eficiente das operações no cache, [mantendo os dados nas consultas tanto quanto possível no [cache L1 e L2]{.blue}]{.marked} muito rápido.
:::
::: {.column width="40%" .fragment}
![Fonte: [blog.min.io/duckdb-and-minio-for-a-modern-data-stack/](https://blog.min.io/duckdb-and-minio-for-a-modern-data-stack/)](images/caches.jpeg)
:::
::::

## O zoológico dos sistemas operacionais

- Sistemas operacionais de computadores de grande porte, [de alto desempenho e alta disponibilidade]{.marked} (*mainframes*)
- Sistemas operacionais de servidores
- Sistemas operacionais de computadores pessoais
- Sistemas operacionais de computadores portáteis
- Sistemas operacionais embarcados
- Sistemas operacionais de tempo real

## Conceitos de sistemas operacionais

- [**Processos:**]{.blue} [um processo é basicamente um [programa em execução]{.blue}]{.marked} e associado a cada processo está um [espaço de endereçamento]{.blue}, uma lista de posições de mémoria que vai de 0 a algum máximo, onde o processo pode ler e escrever.
- [**Espaços de endereçamento:**]{.blue} diz respeito ao gerenciamento e à [proteção da memória principal do computador]{.marked}, quando se tem multiplos processos sendo executados.
- [**Arquivos:**]{.blue} um sistema de arquivos é uma estrutura usada por um sistema operacional para organizar e gerenciar arquivos em um dispositivo de armazenamento. [Chamadas do sistemas são necessárias para criar, remover, ler escrever arquivos.]{.marked} Existe o conceito de [diretório]{.blue} como uma maneira de agrupar os arquivos

## Conceitos de sistemas operacionais

- [**Entrada/Saída:**]{.blue} o sistema operacional tem um subsistema de E/S para [gerenciamento dos dispositivos]{.marked}.
- [**Proteção:**]{.blue} o sistema operacional [gerencia a segurança
do sistema]{.marked} de maneira que os arquivos, por exemplo,
sejam acessíveis somente por usuários autorizados.
- [**Interpretador de comandos (shell):**]{.blue} é a principal interface entre um usuário e o sistema operacional.

## Conceitos de sistemas operacionais

> *[Memória virtual:]{.blue} A memória virtual proporciona a [capacidade de executar programas maiores do que a memória física da máquina]{.marked}, rapidamente movendo pedaços entre a memória RAM e o disco.*

\

Quando se instala o linux é possível definir o [tamanho da partição do disco que será utilizado pela memória virtual (swap)]{.marked}.

```{.bash code-line-numbers="false"}
free
```
```
              total        used        free      shared  buff/cache   available
Mem:        13290480      480388    10480984        1252     2329108    12527384
Swap:              0           0           0
```

## Chamadas de sistema

Já vimos que os sistemas operacionais apresentam duas funções: abstrações para os usuários [e gerenciamento de recursos.]{.fragment  fragment-index=1 .semi-fade-out}

::: {.fragment fragment-index=1}
- A parte do [gerenciamento de recursos]{.blue} fica [transparente para os usuários]{.marked} e é feita automaticamente.
:::
::: {.fragment fragment-index=2}
- Na sua maior parte a interação entre programas de usuários e o sistema operacional lida com as [abstrações]{.blue}.
:::

## Chamadas de sistema

\

:::: columns
::: {.column width="60%"}
![A manipulação de uma aplicação de usuário que invoca a chamada de sistema `open()`](images/silberschatz-02-06.png)
:::
::: {.column width="40%"}
1. A função `open()` é executada em [modo usuário]{.blue}
2. No [modo núcleo/kernel]{.blue} é feita uma busca em um vetor de endereços a implementação da chamada `open()`
3. O `open()` é executado e [retorna o resultado]{.marked} para o sistema operacional e sequencialmente para o usuário
:::
::::

## Chamadas de sistema

> API: *elemento que proporciona uma ligação física ou lógica entre dois sistemas ou partes de um sistema que não poderiam ser conectados diretamente.*

- API define um [conjunto de normas que possibilita a comunicação]{.marked} entre plataformas por meio de uma série de padrões e protocolos.
- Por meio de APIs, desenvolvedores podem criar novos softwares e aplicativos capazes de se comunicar com outras plataformas. Por exemplo: [caso um desenvolvedor queira criar um aplicativo de fotos para Android, ele poderá ter acesso à câmera do celular através da API do sistema operacional, sem ter a necessidade de criar uma nova interface de câmera do zero.]{.marked}. 

\

*Aqui uma abstração da complexidade!*

## Chamadas de sistema

> *As chamadas de sistema sempre foram o meio pelo qual os programas de [espaço do usuário]{.blue} podem acessar os [serviços do kernel]{.blue}*

<center>

```{mermaid}
flowchart LR;
    subgraph U["Usuário"]
    A(Função <br> mkdir) --> B[Interface de Chamada de Sistema <br> sys_mkdir];
    end
    subgraph K["Kernel"]
    B --> C[Manipulador de <br> Chamada de Sistema];
    end

    style U fill:#ffffff
    style K fill:#e4e4e4
```
</center>

:::: columns
::: {.column}

- Cria um novo diretório (pasta)
```{.bash code-line-numbers="false"}
mkdir mynewdir
```
- Visualizar a interface de chamada
```{.bash code-line-numbers="false"}
cat /usr/include/asm*/unistd.h | grep -B 1 sys_mkdir
```
```
#define __NR_mkdirat 34
__SYSCALL(__NR_mkdirat, sys_mkdirat)
```
:::
::: {.column}

- Visualizar os registradores onde são armazenados as info da chamada
```{.bash code-line-numbers="false"}
cpuid -1 -r | head -3
```
```
CPU:
   0x00000000 0x00: eax=0x0000000d ebx=0x756e6547 ecx=0x6c65746e edx=0x49656e69
   0x00000001 0x00: eax=0x000406f0 ebx=0x01020800 ecx=0xfefa3203 edx=0x1f8bfbff
```
:::
::::

## Chamadas de sistema

Uma chamada de sistem pode necessitar de outras chamadas serem realizadas

```{.bash code-line-numbers="false"}
strace -c mkdir mynewdir
```

```
% time     seconds  usecs/call     calls    errors syscall
------ ----------- ----------- --------- --------- ----------------
  0.00    0.000000           0         5           read
  0.00    0.000000           0         8           close
  0.00    0.000000           0        18           mmap
  0.00    0.000000           0         7           mprotect
  0.00    0.000000           0         1           munmap
  0.00    0.000000           0         3           brk
  0.00    0.000000           0         4           pread64
  0.00    0.000000           0         2         2 access
  0.00    0.000000           0         1           execve
  0.00    0.000000           0         1           mkdir
  0.00    0.000000           0         2         2 statfs
  0.00    0.000000           0         2         1 arch_prctl
  0.00    0.000000           0         1           set_tid_address
  0.00    0.000000           0        26        20 openat
  0.00    0.000000           0        26        20 newfstatat
  0.00    0.000000           0         1           set_robust_list
  0.00    0.000000           0         1           prlimit64
  0.00    0.000000           0         1           getrandom
  0.00    0.000000           0         1           rseq
------ ----------- ----------- --------- --------- ----------------
100.00    0.000000           0       111        45 total
```

## Chamadas de sistema

\

:::: columns
::: {.column width="33%" .fragment}
Os desenvolvedores de aplicações projetam programas de acordo com uma interface de programação de aplicações (API — application programming interface).


:::
::: {.column width="33%" .fragment}
[A API especifica um conjunto de funções que estão disponíveis para um programador de aplicações,]{.marked} incluindo os parâmetros que são passados a cada função e os valores de retorno que o programador pode esperar.

:::
::: {.column width="33%" .fragment}
[*Portable Operating System Interface*]{.blue} (POSIX) é uma API para o sistema UNIX/Linux.
:::
::::

::: {.fragment}
*Se usarmos o comando `ps`, ele deverá se comportar da mesma forma no OpenBSD, Debian e macOS.*
:::

## Chamadas de sistema

\

:::: columns
::: {.column}

- Uso da função `write` em `C++`

```{.cpp filename="write.cpp" code-line-numbers="1|3-6"}
#include<unistd.h>

int main() 
{
    write(1, "Ola Mundo!", 10);
}
```
:::
::: {.column}
- Nas linguagens de programação C e C++, `unistd.h` é o nome do arquivo de cabeçalho que fornece acesso à API do sistema operacional [POSIX]{.blue}.
- Compilar: `g++ write.cpp`
- Executar: `./a.out`
:::
::::

## Chamada de sistema

\

Abaixo a chamada de sistema `write` sendo utilizada

```{.bash code-line-numbers="false"}
strace -o trace.txt ./a.out

cat trace.txt | grep -A 5 write
```
```
write(1, "Ola Mundo!", 10)              = 10
exit_group(0)                           = ?
+++ exited with 0 +++
```

## Chamada de sistema

\

No fim das contas um `printf` realiza a mesma chamada de sistema `write`

:::: columns
::: {.column}
```{.cpp filename="write.cpp" code-line-numbers="1|3-6"}
#include<stdio.h>

int main() 
{
    printf("Ola Mundo!");
}
```
:::
::: {.column}
```{.bash code-line-numbers="false"}
strace -o trace.txt ./a.out

cat trace.txt | grep -A 5 write
```
```
write(1, "Ola Mundo!", 10)              = 10
exit_group(0)                           = ?
+++ exited with 0 +++
```
:::
::::

## Chamada de sistema

\

```{.bash code-line-numbers="false"}
strace -o trace.txt python -c 'print("Ola Mundo!")'

cat trace.txt | grep -A 5 write 
```

- Será realizada a chamada de sistema `write`?
- Comparar com as chamadas de sistema feitas com `C++`

## Chamadas de sistema

- Chamadas de sistema para gerenciamento de processos
- Chamadas de sistema para gerenciamento de arquivos
- Chamadas de sistema para gerenciamento de diretórios
- Chamadas de sistema diversas

## Chamadas de sistema para gerenciamento de processos 

\

| Chamada                                | Descrição                                       |
|----------------------------------------|-------------------------------------------------|
| `pid = fork()`                         | Criar um processo filho idêntico ao pai         |
| `pid = waitpid(pid, statloc, options)` | Espera que um processo filho seja concluído     |
| `s = execve(name, argv, environp)`     | Substitui a imagem do núcleo de um processo     |
| `exit(status)`                         | Conclui a execução do processo e devolve status |


## Chamadas de sistema para gerenciamento de processos 
### `fork`

::: {.panel-tabset}
### Python
```{.python filename="fork_exemplo.py" code-line-numbers="|1|4|6-7|9|11-12"}
import os
import sys

pid = os.fork()

if pid < 0:
  sys.exit("Fork fail")

print(f"Hello world!, process_id(pid) = {os.getpid()}\n")

# Hello world!, process_id(pid) = 7534
# Hello world!, process_id(pid) = 7536
```

### C++
```{.cpp filename="fork_exemplo.cpp" code-line-numbers="|2|6|11|15-16"}
#include <stdio.h>
#include <unistd.h>

int main()
{
	pid = fork();
	if(pid < 0){
	perror("Fork fail");
	_exit(1);
	}
	printf("Hello world!, process_id(pid) = %d \n", getpid());
	return 0;
}

// Hello world!, process_id(pid) = 685 
// Hello world!, process_id(pid) = 686
```
:::

## Chamadas de sistema para gerenciamento de processos 
### `waitpid`

::: {.panel-tabset}

### Python
```{.python filename="waitpid_exemplo.py" code-line-numbers="|1|3-5|7|8-11|12-13"}
import os

i = 1
waitpid_return = ()
print(f"process_id(pid) parent= {os.getpid()}\n")

pid = os.fork()
if pid > 0:
  for i in range(1, 6):
    waitpid_return = os.waitpid(pid, os.WNOHANG)
    print(f"{i}, process_id(pid) child = {pid}, waitpid = {waitpid_return}\n")
else:
  print(f"{i}, process_id(pid) child = {pid}, waitpid = {waitpid_return}\n")
```

### C++
```{.cpp filename="waitpid_exemplo.cpp" code-line-numbers="1-6|9-10|13-16|18-21"}
#include <stdio.h>
#include <unistd.h>
#include <sys/wait.h>
int i = 1;
int pid;
int waitpid_return;
int main ()
{   
    printf("process_id(pid) parent= %d\n", getpid());
    pid = fork();
    if (pid != 0)
    {   
      
      for (int i = 1; i < 5; i++) {
        waitpid_return = waitpid(pid, NULL, WNOHANG);
        printf("%d, process_id(pid) child = %d, waitpid = %d\n", i, pid, waitpid_return);
      }
    }
    else {
        waitpid_return = waitpid(pid, NULL, WNOHANG);
        printf("%d, process_id(pid) child = %d, waitpid = %d\n", i, pid, waitpid_return);}
        return 0;
    }
```
:::

## Chamadas de sistema para gerenciamento de processos 
### `execve`

::: {.panel-tabset}
### C++
```{.cpp filename="execve.cpp"}
#include <unistd.h>
#include <iostream>
#include <string>

std::string c = "/bin/ls";
std::string p = "-lh";
char *args[] = {c.data(), p.data()};
int main() {
  execve(args[0], args, NULL);
}

```
:::

## Chamadas de sistema para gerenciamento de diretórios

\

| Chamada                          | Descrição                                       |
|----------------------------------|-------------------------------------------------|
| `s = mkdir(name, mode)`          | Cria um novo diretório                          |
| `s = rmdir(name)`                | Remove um diretório                             |
| `s = link(name1, name2)`         | Cria um nova entrada name1 apontando para name2 |
| `s = unlink(name)`               | Remove uma entrada de diretório                 |
| `s = mount(special, name, flag)` | Monta um sistema de arquivos                    |
| `s = unmount(special)`           | Desmonta um sistema de arquivos                 |

## Chamadas de sistema para gerenciamento de diretórios

### Exemplos

```{.bash code-line-numbers="false"}
# Criar um novo diretório
mkdir mynewdir

# Remover um diretório
rmdir mynewdir

# Criar link entre arquivos
link myfile1 myfile2

# Criar link simbólico (atalho)
ln -s myfile1 myfile2

```

## Alguns comandos úteis

\

```{.bash code-line-numbers="false"}
# Acessar o manual de um comando
man mkdir

# Criar um novo diretório
mkdir novapasta

# Criar um novo diretório contendo outro diretório (pasta)
mkdir -p novapasta/outrapasta

# Criar um diretório com alguma permissão definida
mkdir -m 700 novapasta

# Remover um diretório vazio
rmdir novapasta
```

## Alguns comandos úteis

\

```{.bash code-line-numbers="false"}
# Criar um arquivo em branco
touch meuarquivo.txt

# Criar um arquivo com algum conteúdo
echo "Ola mundo!" > meuarquivo.txt

# Adicionar uma nova linha a um arquivo existente
echo "Nova linha" >> meuarquivo.txt 

# Remover um arquivo
rm meuarquivo.txt

# Remover um diretório
rm -r novapasta
```

## Alguns comandos úteis

```{.bash code-line-numbers="false"}
# Mover arquivos
mv meuarquivo.txt /outrapasta

# Renomear arquivos
mv meuarquivo.txt novonome.txt

# Copiar arquivos
cp meuarquivo.txt copiadoarquivo.txt
```

## Chamadas de sistema para gerenciamento diversos

\

| Chamada                    | Descrição                                |
|----------------------------|------------------------------------------|
| `s = chdir(dirname)`       | Altera o diretório de trabalho           |
| `s = chmod(name, mode)`    | Altera os bits de proteção de um arquivo |
| `s = kill(pid, signal)`    | Envia um sinal para um processo          |

## Chamadas de sistema para gerenciamento diversos

### Exemplos

```{.bash code-line-numbers="false"}
# Alterar um diretório (geralmente se usa cd)
chdir <diretório existente>
cd <diretório existente>

# Define a proteção de um arquivo
chmod 700 myfile

# "Matar" um processo
kill <pid>
```

## Proteção de um arquivo

Devo utilizar um valor octal para *usuário/grupo/outros*

| Octal | Binário | Código de Proteção                 |     |
|-------|---------|------------------------------------|-----|
| 0     | 000     | Nenhuma permissão                  |`---`|          
| 1     | 001     | Permissão de execução              |`--x`|
| 2     | 010     | Permissão de escrita               |`-w-`|
| 3     | 011     | Permissão de escrita e execução    |`-wx`|
| 4     | 100     | Permissão de leitura               |`r--`|
| 5     | 101     | Permissão de leitura e execução    |`r-x`|
| 6     | 110     | Permissão de leitura e escrita     |`rw-`|
| 7     | 111     | Todas as permissões                |`rwx`|

```{.bash code-line-numbers="false"}
# Permissão de escrita para o usuário (2) e nenhuma permissão para o grupo (0) e outros (0)
chmod 200 myfile
ls -l myfile
```
```
--w-------  1 thop  staff  0 27 Mar 16:18 myfile
```

```{.bash code-line-numbers="false"}
# Permissão de leitura/escrita para o usuário (6) e permissão de leitura para o grupo (4)
chmod 640 myfile
ls -l myfile
```
```
-rw-r-----  1 thop  staff  0 27 Mar 16:18 myfile
```

# Estruturas do Sistema Operacional

> *Os sistemas operacionais podem ser organizados de várias maneiras, dependendo de sua estrutura interna e de como eles gerenciam os recursos do computador.*

## Monolítico

\

- Nesta estrutura, todo o sistema operacional [é implementado como um único programa de grande porte]{.marked}.
- Todas as funcionalidades do sistema operacional, como gerenciamento de memória, gerenciamento de processos e sistemas de arquivos, residem no kernel.
- Exemplos [incluem sistemas operacionais mais antigos]{.marked}, como MS-DOS e versões mais antigas do UNIX.

## Microkernel

\

- Neste modelo, o kernel é mínimo e [fornece apenas as funcionalidades básicas]{.marked}, como gerenciamento de memória, comunicação entre processos e escalonamento de CPU.
- Funcionalidades adicionais, como sistemas de arquivos e drivers de dispositivos, são implementadas como processos de usuário que se comunicam com o kernel.
- Exemplos incluem o MINIX e o Symbian.

*Desse modo, um erro no driver de áudio fará que o som fique truncado ou pare, [mas não derrubará o computador.]{.marked}*

## Híbrido

\

- Esta abordagem combina elementos do [kernel monolítico e do microkernel]{.blue}.
- [O kernel contém algumas funcionalidades essenciais,]{.marked} como gerenciamento de memória e escalonamento de processos, enquanto outras funcionalidades são implementadas como módulos do kernel ou como processos de usuário.
- Exemplos incluem Linux, Windows NT/2000/XP/Vista/7/8/10.

## Sistemas Virtuais

\

- Esta estrutura cria uma máquina virtual que [simula uma arquitetura de hardware]{.marked} para cada processo.
- Cada processo tem a ilusão de que possui seu próprio sistema operacional.
- Exemplos incluem máquinas virtuais como VMware, VirtualBox e Hyper-V.

![(a) Um hipervisor de tipo 1. (b) Um hipervisor de tipo 2 puro. (c) Um hipervisor de tipo 2 na prática. Uma discussão sobre a diferença entre hipervisors 1 e 2: <https://aws.amazon.com/pt/compare/the-difference-between-type-1-and-type-2-hypervisors/>](images/tanenbaum-01-29.jpg){height="250"}

# Gerenciamento de processos

> *O conceito mais central em qualquer sistema operacional é o processo: [uma abstração de um programa em execução.]{.marked}*

## Contador de Programa e Registrador de Instruções 

\

:::: columns
::: {.column}
- [Contador de Programa (*Program Counter*)]{.blue}, é um registrador de propósito especial usado pelo processador para [armazenar o endereço da próxima instrução]{.marked} a ser executada.
- [Registrador de Instruções (*Instruction Register*)]{.blue} contém a [instrução que está sendo executada]{.marked} pela CPU

![Ciclo de instrução básico](images/stallings-03-03.png){width="90%"}

:::
::: {.column}
Início da execução do programa:

1. O [Contador de Programa]{.blue} contém 0x00000000 (digamos que este seja o endereço de início do programa na memória).
2. A instrução codificada é buscada na memória e colocada no [Registrador de Instruções]{.blue}.
3. A instrução é decodificada e executada.
4. Agora é hora de avançar para o próximo endereço de instrução, e seguir o mesmo processo (ciclo de intrução)
:::
::::

## Contador de Programa e Registrador de Instruções 

\

<center>![](images/von-neumann-architecture.jpeg)</center>

## Processos

- Um processo [é apenas uma instância de um programa em execução]{.marked}, incluindo os valores atuais do contador do programa, registradores e variáveis.
- Processos podem ser criados e terminados dinamicamente.
- Cada processo tem seu próprio [espaço de endereçamento]{.blue}.

## O modelo de processo

:::: columns
::: {.column width="50%"}
a. Vemos um computador multiprogramando quatro programas na memória (com contador programa físico).
b. Vemos quatro processos, cada um com seu próprio fluxo de controle e sendo executado independente dos outros (contador de programa lógico). 
c. Vemos que, analisados durante um intervalo longo o suficiente, todos os processos tiveram progresso, mas a qualquer dado instante apenas um está sendo de fato executado.
:::
::: {.column width="50%%"}

\

<center>![](images/tanenbaum-02-01.jpg)</center>

> *Em qualquer sistema de multiprogramação, [a CPU muda de um processo para outro rapidamente, executando cada um por dezenas ou centenas de milissegundos]{.marked}, dando a ilusão do [paralelismo]{.blue}.*
:::
::::

## Criação de processos

> *Sistemas operacionais precisam de alguma maneira criar processos.*

Quatro eventos principais fazem com que os processos sejam criados:

:::: columns
::: {.column width="25%" .fragment}
[Inicialização do sistema]{.blue}. Alguns processos são de (1) primeiro plano, sendo processos que interagem com o usuário; (2) segundo plano, processos que não estão associados a um usuário (*daemons*)
:::
::: {.column width="25%" .fragment}
[Execução de uma chamada de sistema]{.blue} de criação de processo por um processo em execução. [Um processo em execução emitirá chamadas de sistema para criar processos novos para ajudá-lo em seu trabalho]{.marked}
:::
::: {.column width="25%" .fragment}
[Solicitação de um usuário]{.blue} para criar um novo processo. Em sistemas interativos, os usuários podem começar um programa [digitando um comando ou clicando duas vezes]{.marked} sobre um ícone.
:::
::: {.column width="25%" .fragment}
Início de uma [tarefa em lote]{.blue}. *Pense no gerenciamento de estoque ao fim de um dia em uma cadeia de lojas, nesse caso usuários podem submeter tarefas em lote ao servidor (possivelmente de maneira remota).*
:::
::::

## Criação de processos

:::: columns
::: {.column width="40%"}
No UNIX, há apenas uma chamada de sistema para criar um novo processo: [fork]{.blue}. [Essa chamada cria um clone exato do processo que a chamou.]{.marked} Após a fork, os dois processos, o pai e o filho, têm a mesma imagem de memória, as mesmas variáveis de ambiente e os mesmos arquivos abertos. Mas atuam de forma independente.
:::
::: {.column width="60%"}
Como identificar processos filho?

```{.bash filename="child.sh"}
#!/bin/bash
sleep infinity
```

```{.bash filename="parent.sh"}
#!/bin/bash
./child.sh &
sleep infinity
```

```{.bash filename="$"}
parent.sh &
```

Usando:
```{.bash filename="$"}
pgrep -P <parent pid>
pgrep -lP <parent pid>
pstree -p <parent pid>
ps --ppid <parent pid>
ls /proc/<parent pid>/task
cat /proc/<parent pid>/task/<parent pid>/children
```
:::
::::

## Término de processos

:::: columns
::: {.column}
Após um processo ter sido criado, ele começa a ser executado e realiza qualquer que seja o seu trabalho. *No entanto, nada dura para sempre, nem mesmo os processos.* Cedo ou tarde, o novo processo terminará, normalmente devido a uma das condições a seguir:

1. Saída normal (voluntária).
2. Erro fatal (involuntário).
3. Saída por erro (voluntária).
4. Morto por outro processo (involuntário).
:::
::: {.column}
Exemplos:

1. `ctrl + c` para interromper programas ou processos no primeiro plano
2. `!g++ foo.cpp` e `foo.cpp` não existe no diretório
3. Um Erro interno do processo que afeta seu funcionamento, então o usuário é avisado e o programa termina
4. `kill <pid>`
:::
::::

## Hierarquias de processos

:::: columns
::: {.column}
- Em alguns sistemas, quando um processo cria outro, o processo pai e o processo filho continuam a ser associados de certas maneiras. 
- O processo filho pode em si criar mais processos, formando uma hierarquia de processos.

```{filename="$"}
./grandparent.sh
ps -efj | egrep "PGID|children|parent"
kill -9 -<pgid>
```
:::
::: {.column}
```{.bash filename="grandparent.sh"}
#!/bin/bash
bash parent.sh &
bash parent.sh &
for i in {1..100}; do 
sleep 2; 
echo -n "This is the grandparent process $i"; 
done
```

```{.bash filename="parent.sh"}
#!/bin/bash
bash children.sh &
bash children.sh &
for i in {1..100}; do sleep 2; echo -n "This is the parent process $i"; 
done
```

```{.bash filename="children.sh"}
#!/bin/bash
for i in {1..100}; do 
sleep 2; 
echo -n "This is a test in children process $i"; 
done
```
:::
::::

## Estados de processos

\

:::: columns
::: {.column width="60%"}
- Embora cada processo seja uma entidade independente, com seu próprio contador de programa e estado interno, processos muitas vezes precisam interagir entre si.
- Um processo pode gerar alguma saída que outro processo usa como entrada.

\

```{filename="$"}
curl -s https://openbible.com/textfiles/kjv.txt | \
grep "Exodus\s2" | \
head -4
```

:::
::: {.column width="40%"}
São 3 Estados:

- [Em execução]{.blue} (realmente usando a CPU naquele instante).
- [Pronto]{.blue} (executável, temporariamente parado  para deixar outro processo ser executado).
- [Bloqueado]{.blue} (incapaz de ser executado até que algum evento externo aconteça).
:::
::::

## Estados de processos

\

:::: columns
::: {.column}
1. O processo é [bloqueado]{.blue} aguardando uma entrada
2. O escalonador [seleciona outro]{.blue} processo
3. O escalonador [seleciona esse]{.blue} processo
4. A entrada torna-se [disponível]{.blue}
:::
::: {.column}
![Um processo pode estar nos estados em execução, bloqueado ou pronto. Transições entre esses estados ocorrem como mostrado.](images/tanenbaum-02-02.png){width="80%"}
:::
::::

## Estados de processos

O nível mais baixo de um sistema operacional estruturado em processos controla interrupções e escalonamento. Acima desse nível estão processos sequenciais. 

<center>![](images/tanenbaum-02-03.png){height="300"}</center>

> *O [escalonamento]{.blue}, isto é, [decidir qual processo deve ser executado, quando e por quanto tempo, é um assunto importante;]{.marked} nós o examinaremos mais adiante neste capítulo. Muitos [algoritmos]{.blue} foram desenvolvidos para tentar [equilibrar as demandas concorrentes de eficiência para o sistema como um todo e justiça para os processos individuais.]{.marked}*

## Implementação de processos

> *Para implementar o modelo de processos, o sistema operacional mantém uma tabela (um arranjo de estruturas) chamada de [tabela de processos]{.blue}, com uma entrada para cada um deles.*

:::: columns
::: {.column width="40%"}
- Essas entradas contêm informações importantes sobre o [estado do processo]{.blue} quando ele é [trocado do estado em execução para pronto ou bloqueado]{.marked}
- Podendo o processo [retornar precisamente para o mesmo estado em que se encontrava antes de ser interrompido.]{.marked}
:::
::: {.column width="60%"}
![Alguns dos campos de uma entrada típica na tabela de processos](images/tanenbaum-02-04.png)
:::
::::

# Scheduling de Processos

## Scheduling de Processos

\

:::: columns
::: {.column width="33%" .fragment}
O objetivo da multiprogramação é haver [sempre algum processo em execução para maximizar a utilização da CPU.]{.marked}
:::
::: {.column width="33%" .fragment}
O compartilhamento de tempo é [alternar a CPU entre os processos, com tanta frequência]{.marked}, que os usuários possam interagir com cada programa enquanto ele está sendo executado.
:::
::: {.column width="33%" .fragment}
Para alcançar esses objetivos, [o scheduler de processos seleciona um processo disponível]{.marked} (possivelmente em um conjunto de vários processos disponíveis) para execução na CPU.
:::
::::

## Scheduling de Processos

Cada processo é representado, no sistema operacional, por um bloco de controle de processo (PCB - *process control block*) - também chamado bloco de controle de tarefa.

:::: columns
::: {.column width="20%" .fragment}
[Estado do processo]{.blue} pode ser novo, pronto, em execução, em espera, parado, e assim por diante.
:::
::: {.column width="20%" .fragment}
[Contador do programa.]{.blue} indica o endereço da próxima instrução a ser executada para esse processo.
:::
::: {.column width="20%" .fragment}
[Registradores da CPU]{.blue} incluem acumuladores, registradores índice, ponteiros de pilhas e registradores de uso geral, além de qualquer informação do código de condição.
:::
::: {.column width="20%" .fragment}
[Informações de scheduling da CPU]{.blue} incluem a prioridade de um processo, ponteiros para filas de scheduling e quaisquer outros parâmetros de scheduling.
:::
::: {.column width="20%" .fragment}
[Informações de gerenciamento da memória]{.blue} podem incluir itens como o valor dos registradores base e limite e as tabelas de páginas, ou as tabelas de segmentos.
:::
::::

## Fila de scheduling

:::: columns
::: {.column}
Quando os processos entram no sistema, eles são inseridos em uma [fila de *jobs* que é composta por todos os processos no sistema]{.marked}. Os processos que estão residindo na memória principal e estão prontos e esperando execução são mantidos em uma lista chamada fila de prontos.
:::
::: {.column}
![](images/silberschatz-03-04.png)
:::
::::

## Mudança de contexto

\

> *[A alocação da CPU a outro processo requer a execução do salvamento do estado]{.marked} do processo corrente e a restauração do estado de um processo diferente. Essa tarefa é conhecida como [mudança de contexto]{.blue}*

\

- As interrupções fazem com que o sistema operacional tire a CPU de sua tarefa corrente para executar uma rotina do kernel.
- Essas operações ocorrem, com frequência, em sistemas de uso geral. 
- O contexto é representado no PCB do processo.

## Mudança de contexto

\

O tempo gasto na mudança de contexto é puro [*overhead*]{.blue} porque o sistema não executa trabalho útil durante a permuta de processos. [A velocidade da permuta varia de uma máquina para outra, dependendo da velocidade da memória, do número de registradores a serem copiados]{.marked}

## Comunicação Interprocessos

\

> *Os processos que são executados concorrentemente no sistema operacional podem ser [processos independentes]{.blue} ou [processos cooperativos]{.blue}*

\

:::: columns
::: {.column}
[Um processo é [independente]{.blue} quando não pode afetar outros processos em execução]{.marked} no sistema nem ser afetado por eles. Qualquer processo que não compartilhe dados com outros processos é independente.
::: 
::: {.column}
[Um processo é [cooperativo]{.blue} quando pode afetar outros processos em execução no sistema ou pode ser afetado por eles.]{.marked} É claro que qualquer processo que compartilhe dados com outros processos é um processo cooperativo.
::: 
::::

## Comunicação Interprocessos

\

Razões para o fornecimento de um ambiente que permita a cooperação entre processos:

:::: columns
::: {.column width="25%"}
[Compartilhamento de informações.]{.blue} Já que vários usuários podem estar interessados no mesmo bloco de informações (por exemplo, um arquivo compartilhado), devemos fornecer um ambiente que permita o acesso concorrente.
:::
::: {.column width="25%"}
[Aumento da velocidade de computação.]{.blue} Se quisermos que uma tarefa em particular seja executada mais rapidamente, devemos dividi-la em subtarefas a serem executadas em paralelo.
:::
::: {.column width="25%"}
[Modularidade.]{.blue} Podemos querer construir o sistema de forma modular, dividindo suas funções em processos
:::
::: {.column width="25%"}
[Conveniência.]{.blue} Até mesmo um usuário individual pode trabalhar em muitas tarefas ao mesmo tempo. Por exemplo, um usuário pode editar, ouvir música e compilar em paralelo.
:::
:::: 

## Processos cooperativos

\

Processos cooperativos demandam um mecanismo de comunicação entre processos (IPC) que lhes permita trocar dados e informações. Há dois modelos básicos de comunicação entre processos: [memória compartilhada e transmissão de mensagens]{.blue}.

:::: columns
::: {.column width="33%"}
No modelo de [memória compartilhada]{.blue}, estabelece-se uma região da memória que é compartilhada por processos cooperativos. Os processos podem, então, trocar informações lendo e gravando dados na região compartilhada.
:::
::: {.column width="33%"}
No modelo de [transmissão de mensagens]{.blue}, a comunicação ocorre por meio de mensagens trocadas entre os sistemas cooperativos. 
:::
::: {.column width="33%"}
![](images/silberschatz-03-12.png)
:::
::::

## Sistema de memória compartilhada

\

A comunicação entre processos que usam memória compartilhada [requer que os processos em comunicação estabeleçam uma região de memória compartilhada.]{.marked} Normalmente, a região de memória compartilhada reside no espaço de endereçamento do processo que cria o segmento de memória compartilhada. Outros processos que queiram se comunicar usando esse segmento de memória compartilhada devem anexá-lo ao seu espaço de endereçamento. 

## Sistema de memória compartilhada

\

### Condições de corrida

:::: columns
::: {.column}
Em alguns sistemas operacionais, processos que estão trabalhando juntos podem compartilhar de alguma memória comum que cada um pode ler e escrever.
:::
::: {.column}
![](images/tanenbaum-02-21.png)

Veja na figura dois processos querem acessar a memória compartilhada ao mesmo tempo.
:::
::::

## Sistema de memória compartilhada

\

### Regiões críticas

:::: columns
::: {.column}
[Como evitar as condições de corrida?]{.marked} A chave para evitar problemas aqui e em muitas outras situações envolvendo memória compartilhada, arquivos compartilhados e tudo o mais compartilhado é encontrar alguma maneira de [proibir mais de um processo de ler e escrever os dados compartilhados ao mesmo tempo.]{.marked}
:::
::: {.column}
Colocando a questão em outras palavras, o que precisamos é de [exclusão mútua]{.blue}, isto é, alguma maneira de se certificar de que [se um processo está usando um arquivo ou variável compartilhados, os outros serão impedidos de realizar a mesma coisa.]{.marked}

![](images/tanenbaum-02-22.png)

:::
::::

## Regiões críticas

\

[Quatro condições são estabelecidas]{.marked} para se chegar a uma boa solução de corridas:
1. Dois processos jamais podem estar simultaneamente dentro de suas regiões críticas.
2. Nenhuma suposição pode ser feita a respeito de velocidades ou do número de CPUs.
3. Nenhum processo executando fora de sua região crítica pode bloquear qualquer processo.
4. Nenhum processo deve ser obrigado a esperar eternamente para entrar em sua região crítica.

## Exclusão mútua com espera ocupada

### Desabilitando interrupções

:::: columns
::: {.column}
[Com as interrupções desabilitadas, nenhuma interrupção de relógio poderá ocorrer.]{.marked} Afinal de contas, a CPU só é chaveada de processo em processo em consequência de uma interrupção de relógio ou outra, e com as interrupções desligadas, a CPU não será chaveada para outro processo. [Então, assim que um processo tiver desabilitado as interrupções, ele poderá examinar e atualizar a memória compartilhada]{.marked} sem medo de que qualquer outro processo interfira.
:::
::: {.column}
Contudo, em um sistema multinúcleo (isto é, sistema de multiprocessador) [desabilitar as interrupções de uma CPU não evita que outras CPUs interfiram com as operações que a primeira está realizando.]{.marked} Em consequência, esquemas mais sofisticados são necessários.
:::
::::

## Exclusão mútua com espera ocupada

### Variáveis do tipo trava

:::: columns
::: {.column}
Considere ter uma única variável (de trava) compartilhada, inicialmente 0. [Quando um processo quer entrar em sua região crítica, ele primeiro testa a trava. Se a trava é 0, o processo a configura para 1 e entra na região crítica.]{.marked} *Se a trava já é 1,o processo apenas espera até que ela se torne 0.* Desse modo, um 0 significa que nenhum processo está na região crítica, e um 1 significa que algum processo está em sua região crítica.
:::
::: {.column}
Infelizmente, essa ideia contém exatamente a mesma falha fatal que vimos no diretório de spool. Suponha que um processo lê a trava e vê que ela é 0. Antes que ele possa configurar a trava para 1, outro processo está escalonado, executa e configura a trava para 1. Quando o primeiro processo executa de novo, ele também configurará a trava para 1, e [dois processos estarão nas suas regiões críticas ao mesmo tempo.]{.marked}
:::
::::

## Exclusão mútua com espera ocupada

### Alternância explícita

:::: columns
::: {.column}
A variável do tipo inteiro `turn`, inicialmente 0, serve para controlar de quem é a vez de entrar na região crítica e examinar ou atualizar a memória compartilhada. Inicialmente, o processo 0 inspeciona `turn`, descobre que ele é 0 e entra na sua região crítica. O processo 1 também encontra lá o valor 0 e, portanto, espera em um laço fechado testando continuamente turn para ver quando ele vira 1. Testar continuamente uma variável até que algum valor apareça é chamado de espera ocupada.
:::
::: {.column}

```{.python}
while True:
  while turn != 1:
    print("processo 0 na região crítica")
    turn = 1
    print("processo 0 na região não crítica")

while True:
  while turn != 0:
    print("processo 1 na região crítica")
    turn = 0
    print("processo 1 na região não crítica")
```

Digamos que em algum momento os dois processos estão em suas regiões não críticas e o processo 0 colocar `turn` para 1, mas ele termina o seu processo e precisar retornar para região crítica, mas está impedido.
:::
::::

## Exclusão mútua com espera ocupada

\

### Solução de Peterson

Antes de usar as variáveis compartilhadas (isto é, antes de entrar na região crítica), cada processo chama enter_region com seu próprio número de processo, 0 ou 1, como parâmetro. Essa chamada fará que ele espere, se necessário, até que seja seguro entrar. Após haver terminado com as variáveis compartilhadas, o processo chama leave_region para indicar que ele terminou e para permitir que outros processos entrem, se assim desejarem.

## Exclusão mútua com espera ocupada

\

### Solução de Peterson

```{.python}
#!/usr/bin/env python
# -*- coding: utf-8 -*-

import threading
import time

cs = 0
flag_0 = False
flag_1 = False
turn = 0

def thread_0():
    global cs, flag_0, flag_1, turn

    flag_0 = True
    turn = 1
    while (flag_1 and turn == 1):
            continue

    for i in range(10):
        cs += 1
        print("Thread 0: cs =", cs)
        time.sleep(0.1)

    flag_0 = False

def thread_1():
    global cs, flag_0, flag_1, turn

    flag_1 = True
    turn = 0
    while (flag_0 and turn == 0):
        continue

    for i in range(10):
        cs += 1000
        print("Thread 1: cs =", cs)
        time.sleep(0.1)

    flag_1 = False

if __name__ == "__main__":
		t0 = threading.Thread(target=thread_0)
		t1 = threading.Thread(target=thread_1)
		t0.start()
		t1.start()

# Reference: https://www.aspires.cc/implementing-peterson-algorithm-with-python/
```

## Sistemas de Transmissão de Mensagens

\

A transmissão de mensagens fornece um mecanismo para permitir que os processos se comuniquem e sincronizem suas ações sem compartilhar o mesmo espaço de endereçamento. Isso é particularmente útil em um ambiente distribuído em que os processos em comunicação podem residir em diferentes computadores conectados por uma rede. Por exemplo, um programa de bate-papo na Internet poderia ser projetado de modo que os participantes se comuniquem uns com os outros trocando mensagens.

Um recurso de transmissão de mensagens fornece, pelo menos, duas operações:

- send(message)
- receive(message)

## Sistemas de Transmissão de Mensagens

\

### Sockets
Um socket é definido como uma [extremidade de comunicação]{.blue}. [Um par de processos comunicando-se por uma rede emprega um par de sockets — um para cada processo. Um socket é identificado por um endereço IP concatenado com um número de porta.]{.marked} Geralmente, os sockets usam uma arquitetura cliente-servidor. O servidor espera solicitações recebidas de clientes ouvindo em uma porta especificada. Uma vez que uma solicitação seja recebida, o servidor aceita uma conexão proveniente do socket do cliente para completá-la.

## Sisitemas de Transmissão de Mensagens

\

:::: columns
::: {.column}

```{.python filename="server.py"}
import socket


def run_server():
    # create a socket object
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    server_ip = "127.0.0.1"
    port = 8000

    # bind the socket to a specific address and port
    server.bind((server_ip, port))
    # listen for incoming connections
    server.listen(0)
    print(f"Listening on {server_ip}:{port}")

    # accept incoming connections
    client_socket, client_address = server.accept()
    print(f"Accepted connection from {client_address[0]}:{client_address[1]}")

    # receive data from the client
    while True:
        request = client_socket.recv(1024)
        request = request.decode("utf-8") # convert bytes to string
        
        # if we receive "close" from the client, then we break
        # out of the loop and close the conneciton
        if request.lower() == "close":
            # send response to the client which acknowledges that the
            # connection should be closed and break out of the loop
            client_socket.send("closed".encode("utf-8"))
            break

        print(f"Received: {request}")

        response = "accepted".encode("utf-8") # convert string to bytes
        # convert and send accept response to the client
        client_socket.send(response)

    # close connection socket with the client
    client_socket.close()
    print("Connection to client closed")
    # close server socket
    server.close()


run_server()

```
:::
::: {.column}

```{.python filename="client.py"}
import socket


def run_client():
    # create a socket object
    client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    server_ip = "127.0.0.1"  # replace with the server's IP address
    server_port = 8000  # replace with the server's port number
    # establish connection with server
    client.connect((server_ip, server_port))

    while True:
        # input message and send it to the server
        msg = input("Enter message: ")
        client.send(msg.encode("utf-8")[:1024])

        # receive message from the server
        response = client.recv(1024)
        response = response.decode("utf-8")

        # if server sent us "closed" in the payload, we break out of the loop and close our socket
        if response.lower() == "closed":
            break

        print(f"Received: {response}")

    # close client socket (connection to the server)
    client.close()
    print("Connection to server closed")

run_client()

```
:::
::::

\

Exemplo extraído [daqui](https://www.datacamp.com/tutorial/a-complete-guide-to-socket-programming-in-python)

# Threads

\

> *Cada [processo]{.blue} tem um espaço de endereçamento e um único thread de controle. Na realidade, essa é quase a definição de um [processo]{.blue}. Não obstante isso, em muitas situações, é desejável ter múltiplos threads de controle no mesmo espaço de endereçamento executando em quase paralelo, como se eles fossem (quase) processos separados (exceto pelo espaço de endereçamento compartilhado).*

## Threads, miniprocessos

\

> *Por que alguém iria querer ter um tipo de processo dentro de um processo?* Na realidade, há várias razões para a existência desses miniprocessos, chamados [threads]{.blue}

:::: columns
::: {.column width="25%" .fragment}
A capacidade para as [entidades]{.blue} em paralelo [compartilharem um espaço de endereçamento e todos os seus dados entre si.]{.marked}
:::
::: {.column width="25%" .fragment}
[São mais leves do que os processos,]{.marked} eles são mais fáceis (isto é, mais rápidos) para criar e destruir do que os processos.
:::
::: {.column width="25%" .fragment}
Quando há uma computação substancial e também E/S substancial, contar com [threads permite que essas atividades se sobreponham]{.marked}.
:::
::: {.column width="25%" .fragment}
[Threads]{.blue} são úteis em sistemas com múltiplas CPUs, onde o [paralelismo real]{.marked} é possível.
:::
::::

## Um processador de texto com três threads

\

:::: columns
::: {.column}
[Um thread interage com o usuário]{.marked} e o [outro lida com a reformatação em segundo plano]{.marked}. *Tão logo a frase é apagada da página 1, o thread interativo diz ao de reformatação para reformatar o livro inteiro*. Enquanto isso, o thread interativo continua a ouvir o teclado e o mouse e responde a comandos simples como rolar a página 1 enquanto o outro thread está trabalhando com afinco no segundo plano. [Um terceiro thread pode fazer backups de disco sem interferir nos outros dois.]{.marked}
:::
::: {.column}
![](images/tanenbaum-02-07.png)
:::
::::

## Um processador de texto com três threads

\

> *Deve ficar claro que ter três processos em separado não funcionaria aqui, pois todos os três threads precisam operar no documento. [Ao existirem três threads em vez de três processos, eles compartilham de uma memória comum.]{.marked}*

## O modelo de thread clássico

\

:::: columns
::: {.column}
a. vemos três processos tradicionais. Cada processo tem seu próprio espaço de endereçamento e um único thread de controle. [Cada um deles opera em um espaço de endereçamento diferente.]{.marked}
b. vemos um único processo com três threads de controle. Embora em ambos os casos tenhamos três threads. [Todos os três compartilham o mesmo espaço de endereçamento.]{.marked}
:::
::: {.column}
![](images/tanenbaum-02-11.png)

> *Todo thread pode acessar todo espaço de endereçamento de memória dentro do espaço de endereçamento do processo, [um thread pode ler, escrever, ou mesmo apagar a pilha de outro thread.]{.marked} Não há proteção, porque (1) é impossível e (2) não seria necessário.*

:::
::::

## Threads POSIX

\

:::: columns
::: {.column width="33%" .fragment}
Para possibilitar que se escrevam programas com threads portáteis, [o IEEE definiu um padrão para threads]{.marked} no padrão IEEE 1003.1c. O pacote de threads que ele define é chamado [Pthreads]{.blue}.
:::
::: {.column width="33%" .fragment}
Todos os threads têm determinadas propriedades. Cada um tem um identificador, um conjunto de registradores (incluindo o contador de programa), e um conjunto de atributos, que são armazenados em uma estrutura.
:::
::: {.column width="33%" .fragment}

Algumas das chamadas de função do Pthreads:

![](images/tanenbaum-02-14.png)
:::
::::

## Executando Threads

\

```{.python filename="multiple_threads.py" code-line-numbers="|9|12-15|22-27|29-32"}

"""
Executando Múltiplas Threads

https://realpython.com/intro-to-python-threading/
"""

import logging
import threading
import time

def thread_function(name):
    logging.info("Thread %s: starting, ID: %s", name, threading.get_native_id())
    time.sleep(2)
    logging.info("Thread %s: finishing", name)

if __name__ == "__main__":
    format = "%(asctime)s: %(message)s"
    logging.basicConfig(format=format, level=logging.INFO,
                        datefmt="%H:%M:%S")

    threads = list()
    for index in range(3):
        logging.info("Main    : create and start thread %d.", index)
        x = threading.Thread(target=thread_function, args=(index,))
        threads.append(x)
        x.start()

    for index, thread in enumerate(threads):
        logging.info("Main    : before joining thread %d.", index)
        thread.join()
        logging.info("Main    : thread %d done", index)
```

## Convertendo de um thread para multithread

### Conflitos entre threads sobre o uso de uma variável global

\

:::: columns
::: {.column .fragment}
Conflitos entre threads sobre o uso de uma variável
global.
![](images/tanenbaum-02-19.png){width="90%"}
:::
::: {.column .fragment}
Threads podem ter variáveis globais individuais.

![](images/tanenbaum-02-20.png){width="50%"}
:::
::::

# Scheduling da CPU

> *O scheduling da CPU é a base dos sistemas operacionais multiprogramados. Alternando a CPU entre os processos, o sistema operacional pode tornar o computador mais produtivo.*

## Ciclo de Picos de CPU e I/O



:::: columns
::: {.column}
O sucesso do scheduling da CPU depende de uma propriedade observada nos processos: a execução de processos consiste em um ciclo de [execução da CPU e espera por I/O.]{.marked} Os processos se alternam entre esses dois estados. A execução do processo começa com um pico de CPU. Esse é seguido por um pico de I/O, que é seguido por outro pico de CPU e, então, outro pico de I/O, e assim por diante. Eventualmente, o último pico de CPU termina com o sistema solicitando o encerramento da execução
:::
::: {.column}

<center>
![](images/silberschatz-06-01.png){width="45%"}
</center>
<center>
![](images/silberschatz-06-02.png){width="50%"}
</center>

:::
::::

## Scheduler da CPU

\

Sempre que a CPU se torna ociosa, o sistema operacional deve selecionar um dos processos na fila de prontos para ser executado. O processo de seleção é realizado pelo scheduler de curto prazo, ou scheduler da CPU. O scheduler seleciona um processo entre os processos na memória que estão prontos para execução e aloca a CPU a esse processo.

## Scheduling com Preempção

\

Decisões de scheduling da CPU podem ser tomadas sob as seguintes circunstâncias:

1. Quando um processo passa do estado de execução para o estado de espera [por exemplo, como resultado de uma solicitação de I/O ou de uma invocação a `wait` para o encerramento de um processo-filho]{.marked}
2. Quando um processo passa do estado de execução para o estado de pronto (por exemplo, quando ocorre uma interrupção)
3. Quando um processo passa do estado de espera para o estado de pronto (por exemplo, na conclusão de I/O)
4. Quando um processo termina


## Scheduling com Preempção

\

Nas situações 1 e 4, não há alternativa no que diz respeito ao scheduling. Um novo processo (se existir um na fila de prontos) deve ser selecionado para execução. Há uma alternativa, no entanto, nas situações 2 e 3.

\ 

Quando o scheduling ocorre apenas sob as circunstâncias 1 e 4, dizemos que o esquema de scheduling é sem preempção ou cooperativo. Caso contrário, ele tem preempção.

## Despachante

\

Outro componente envolvido na função de scheduling da CPU é o [despachante]{.blue}. O despachante [é o módulo que passa o controle da CPU ao processo selecionado pelo scheduler de curto prazo]{.marked}. Essa função envolve o seguinte:

- Mudança de contexto
- Mudança para a modalidade de usuário
- Salto para a locação apropriada no programa do usuário para que ele seja reiniciado.

\

O tempo que o despachante leva para interromper um processo e iniciar a execução de outro é conhecido como [latência do despacho]{.blue}.

## Critérios de Scheduling {.smaller}

Diferentes algoritmos de scheduling da CPU têm diferentes propriedades, e a escolha de um algoritmo específico pode favorecer uma classe de processos em vez de outra. Seguem alguns critérios para comparação de algorítmos:

:::: columns
::: {.column width="20%"}
[Utilização da CPU.]{.blue} Queremos manter a CPU tão ocupada quanto possível. [Conceitualmente, a utilização da CPU pode variar de 0 a 100%.]{.marked} Em um sistema real, ela deve variar de 40% (para um sistema pouco carregado) a 90% (para um sistema pesadamente carregado).
:::
::: {.column width="20%"}
[Throughput.]{.blue} Se a CPU está ocupada executando processos, trabalho está sendo realizado. [Uma medida de trabalho é o número de processos que são concluídos por unidade de tempo, chamado throughput.]{.marked} Para processos longos, essa taxa pode ser de um processo por hora; para transações curtas, ela pode ser de dez processos por segundo.
:::
::: {.column width="20%"}
[Tempo de turnaround.]{.blue} Do ponto de vista de um processo específico, o critério importante é quanto tempo ele leva para ser executado. [O intervalo entre o momento em que o processo é submetido e o momento de sua conclusão é o tempo de turnaround.]{.marked} O tempo de turnaround é a soma dos períodos gastos em espera para entrar na memória, em espera na fila de prontos, em execução na CPU, e executando I/O.
:::
::: {.column width="20%"}
[Tempo de espera.]{.blue} O algoritmo de scheduling da CPU não afeta o período de tempo durante o qual um processo é executado ou faz I/O. [Ele afeta somente o período de tempo que um processo gasta esperando na fila de prontos.]{.marked} O tempo de espera é a soma dos períodos gastos em espera na fila de prontos.
:::
::: {.column width="20%"}
[Tempo de resposta.]{.blue} Em um sistema interativo, o tempo de turnaround pode não ser o melhor critério. Com frequência, um processo consegue produzir alguma saída bem mais cedo e pode continuar computando novos resultados enquanto resultados anteriores estão sendo exibidos para o usuário.
:::
::::

## Algoritmos de Scheduling

\

### Scheduling "Primeiro-a-Chegar, Primeiro-a-Ser-Atendido"

O algoritmo mais simples de scheduling da CPU é o algoritmo "primeiro-a-chegar, primeiro-a-ser-atendido" (FCFS – first-come, first-served). 
- Nesse esquema, o processo que solicita a CPU primeiro é o primeiro a usá-la. 
- Quando um processo entra na fila de prontos, seu PCB é conectado na cauda da fila. Quando a CPU está livre, ela é alocada ao processo na cabeça da fila.
- O lado negativo é que o tempo médio de espera na política FCFS geralmente é bem longo.

## Algoritmos de Scheduling

\

### Scheduling Menor-Job-Primeiro

Esse algoritmo associa a cada processo a duração do próximo pico de CPU do processo. Quando a CPU está disponível, ela é atribuída ao processo que tem o próximo pico de CPU mais curto

## Algoritmos de Scheduling

\

### Scheduling por Prioridades

Uma prioridade é associada a cada processo, e a CPU é alocada ao processo com a prioridade mais alta. Processos com prioridades iguais são organizados no schedule em ordem FCFS. O algoritmo SJF é simplesmente um algoritmo por prioridades em que a prioridade (p) é o inverso do próximo pico de CPU (previsto). Quanto maior o pico de CPU, menor a prioridade, e vice-versa.

## Algoritmos de Scheduling

\

### Scheduling Round-Robin

O scheduler da CPU seleciona o primeiro processo da fila de prontos, define um timer com interrupção após 1 quantum de tempo e despacha o processo.

Portanto, uma entre duas coisas ocorrerá. O processo pode ter um pico de CPU menor do que 1 quantum de tempo. Nesse caso, o próprio processo liberará a CPU voluntariamente. O scheduler passará então para o próximo processo na fila de prontos. Se o pico de CPU do processo em execução corrente for maior do que 1 quantum de tempo, o timer será desligado e causará uma interrupção para o sistema operacional. Uma mudança de contexto será executada e o processo será inserido na cauda da fila de prontos. O scheduler da CPU selecionará então o próximo processo na fila de prontos.


# Gerenciamento de memória

## Gerenciamento de memória

\

> *O que todo programador gostaria é de uma memória privada, infinitamente grande e rápida, que fosse não volátil também, isto é, não perdesse seus conteúdos quando faltasse energia elétrica. Aproveitando o ensejo, por que não torná-la barata, também? Infelizmente, a tecnologia ainda não produz essas memórias no momento.*

## Hierarquia de memória

\

Ao longo dos anos, as pessoas descobriram o conceito de [hierarquia de memórias]{.blue}, em que os computadores têm alguns megabytes de memória cache volátil, cara e muito rápida, alguns gigabytes de memória principal volátil de velocidade e custo médios, e alguns terabytes de armazenamento em disco em estado sólido ou magnético não volátil, barato e lento, sem mencionar o armazenamento removível, com DVDs e dispositivos USB. [É função do sistema operacional abstrair essa hierarquia em um modelo útil e então gerenciar a abstração.]{.marked}

*A parte do sistema operacional que gerencia (parte da) hierarquia de memórias é chamada de gerenciador de memória.*

## A noção de um espaço de endereçamento

\

Dois problemas têm de ser solucionados para permitir que múltiplas aplicações estejam na memória ao mesmo tempo sem interferir umas com as outras: [proteção e realocação.]{.marked}

\

Uma solução foi inventar uma nova abstração para a memória: o espaço de endereçamento. Da mesma forma que o conceito de processo cria uma espécie de CPU abstrata para executar os programas, [o espaço de endereçamento cria uma espécie de memória abstrata para abrigá-los.]{.marked} [Um espaço de endereçamento é o conjunto de endereços que um processo pode usar para endereçar a memória.]{.blue} [Cada processo tem seu próprio espaço de endereçamento, independente daqueles pertencentes a outros processos]{.marked} (exceto em algumas circunstâncias especiais onde os processos querem compartilhar seus espaços de endereçamento).







# Instalação e Configuração do Linux

## [Instalação via WSL](https://learn.microsoft.com/pt-br/windows/wsl/install)

Abra o PowerShell e execute

```{.bash filename="PowerShell"}
wsl --install
```

Por padrão será instalada a distribuição Ubuntu.

\

Caso queira instalar uma outra distribuição adcione o argumento `-d` e o nome da distribuição

```{.bash filename="PowerShell"}
wsl --install -d <nome da distribuição>
```

## [Configuração do ambiente](https://learn.microsoft.com/pt-br/windows/wsl/setup/environment)

\

- Após a instalação será necessário definir um usuário e uma senha
- Caso você não seja o administrador da máquina, será necessária algumas configurações adicionais:

No PowerShell execute o comando para poder acessar o usuário `root`:

```{.bash filename="PowerShell"}
wsl --install -d <nome da distribuição> -u <nome do usuário>
```

Por exemplo caso tenha instalado o Debian, será `-d Debian`

- Adicionar o seu usuário no sudoers para ter acesso a alguns privilégios

No terminal do linux digitar o comando

```{.bash filename="$"}
usermod -aG sudo <nome do usuário>
```

## Instalando programas

\

Nas distribuições derivadas do Debian o gerenciador de pacotes é o `apt`

- Para instalar o programa `cmatrix`

```{.bash filename="$"}
sudo apt install cmatrix
```

Para executar escreva `cmatrix` no terminal

```{.bash filename="$"}
cmatrix
```

## Erros que podem surgir na instalação

\

Comandos que podem ser executados para solucionar erros de instalação

```{.bash}
sudo apt install <nome do pacote> --fix-missing
```

```{.bash}
sudo apt update
sudo apt --fix-broken install
sudo apt install <nome do pacote>
```

## Alguns programas úteis

\

- `neovim` editor de código
- `g++` compilador de código `c++`
- `tmux` permite que várias sessões de terminal sejam acessadas simultaneamente em uma única janela
- `wget` permite fazer download de conteúdos da web

Para instalar todos eles de uma vez

```{.bash filename="$"}
sudo apt install neovim g++ tmux wget
```






















