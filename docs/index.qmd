---
title: "Sistemas Operacionais"
author: "Thiago Pires"
title-slide-attributes:
  data-background-image: cover.gif
  data-background-position: cover
format: 
  revealjs:
    theme: theme.scss
    width: 1600
    height: 900
    footer: "[github.com/unasp-aulas/sistemas-operacionais](https://github.com/unasp-aulas/sistemas-operacionais)"
    slide-number: true
    show-slide-number: all
html-math-method: mathjax
code-annotations: below
self-contained: true
---

# Fundamentos de Sistemas Operacionais

\

> [A função do [sistema operacional]{.blue} é fornecer aos programas do usuário um modelo do computador melhor]{.marked}, mais simples e mais limpo, assim como lidar com o gerenciamento de todos os recursos mencionados. *A maioria dos computadores tem dois modos de operação: [modo núcleo e modo usuário.]{.blue}*

## Fundamentos de Sistemas Operacionais

:::: columns
::: {.column width="40%"}

\

O sistema operacional opera em [modo núcleo]{.blue} (também chamado modo supervisor). Nesse modo, [ele tem acesso completo a todo o hardware e *pode executar qualquer instrução]{.marked} que a máquina for capaz de executar.*
:::
::: {.column width="60%"}

\

Observe, na figura a seguir, uma visão geral simplificada dos [principais componentes]{.blue}:

![](images/tanenbaum-01-01.png)
:::
::::

## Fundamentos de Sistemas Operacionais

\

:::: columns
::: {.column width="33%" .fragment fragment-index=1}
O resto do software opera em [modo usuário]{.blue}, no qual apenas um subconjunto das instruções da máquina está disponível.
:::
::: {.column width="33%" .fragment fragment-index=2}
A diferença entre os [modos]{.blue} exerce papel crucial na maneira como os sistemas operacionais funcionam.
:::
::: {.column width="33%" .fragment fragment-index=3}
[Os sistemas operacionais são enormes, complexos]{.marked} e têm vida longa. O código-fonte do coração de um sistema operacional como Linux ou Windows tem cerca de cinco milhões de linhas.
:::
::::

## O que é um sistema operacional?

\

> *Os sistemas operacionais realizam [duas funções essencialmente não relacionadas]{.marked}: [(1) fornecer a programadores de aplicativos (e programas aplicativos, claro) um conjunto de recursos abstratos limpo em vez de recursos confusos de hardware, e]{.fragment fragment-index=2  .semi-fade-out} [(2) gerenciar esses recursos de hardware]{.fragment fragment-index=2}*

## O que é um sistema operacional? 

\

:::: columns
::: {.column width="30%"}
> *Sistemas operacionais transformam o [feio em belo]{.marked}, como mostrado na figura:*
:::
::: {.column width="70%"}
![](images/tanenbaum-01-02.png){width="80%"}
:::
::::

[Usando essa [abstração]{.blue}, os programas podem criar, escrever, ler arquivos, sem ter que lidar com detalhes complexos de como o hardware funciona]{.fragment}

## O que é um sistema operacional? 

\

> *[O conceito de um sistema operacional como fundamentalmente [fornecendo abstrações]{.marked} para programas aplicativos é uma visão top-down (abstração de cima para baixo).]{.fragment fragment-index=2 .semi-fade-out} [Uma visão alternativa, bottom-up (abstração de baixo para cima), sustenta que o sistema operacional está ali para [gerenciar todas as partes de um sistema complexo]{.marked}.]{.fragment fragment-index=2}*

## O que é um sistema operacional? 

\

:::: columns
::: {.column width="30%"}
O gerenciamento de recursos inclui a [multiplexação]{.blue} (compartilhamento) de recursos de duas maneiras diferentes: [no tempo e no espaço]{.marked}. 
:::
::: {.column width="70%"}
::: {.fragment fragment-index=2 .semi-fade-out}
- Quando um recurso é [multiplexado no tempo]{.marked}, diferentes programas ou usuários se revezam usando-o.
:::
::: {.fragment fragment-index=2}
- O outro tipo é a [multiplexação de espaço]{.marked}. Em vez de os clientes se revezarem, cada um tem direito a uma parte do recurso.
:::
:::
::::

## O que é um sistema operacional? 

\

1. *Quando múltiplas saídas de impressão estão na fila para serem impressas em uma única impressora, uma decisão tem de ser tomada sobre qual deve ser impressa em seguida.*

::: {.fragment}
 [Multiplexado no tempo]{.blue}
:::

2. *Em vez de os clientes se revezarem, cada um tem direito a uma parte do recurso. Por exemplo, a memória principal é normalmente dividida entre vários programas sendo executados, de modo que cada um pode ser residente ao mesmo tempo (por exemplo, a fim de se revezar usando a CPU).*

::: {.fragment}
 [Multiplexado no espaço]{.blue}
:::

## Revisão sobre hardware de computadores

\

:::: columns
::: {.column width="30%"}
> *Um sistema operacional está intimamente ligado ao hardware do computador no qual ele é executado*
:::
::: {.column width="70%"}
![](images/tanenbaum-01-06.png)
:::
::::

\

A CPU, memória e dispositivos de E/S estão todos conectados por um [sistema de barramento (*bus*)]{.marked} e comunicam-se uns com os outros sobre ele.

## Revisão sobre hardware de computadores

\

### Processadores

> *O "cérebro" do computador é a CPU. O ciclo básico de toda CPU é buscar a primeira instrução da memória, decodificá-la para determinar o seu tipo e operandos, executá-la.*

\

:::: columns
::: {.column width="33%" .fragment}
[Cada CPU tem um conjunto específico de instruções]{.marked} que ela consegue executar. *Desse modo, um processador x86 não pode executar programas ARM.*

:::
::: {.column width="33%" .fragment}
As CPUs têm alguns
[registradores]{.blue} internos para armazenamento de variáveis
e resultados temporários.
:::
::: {.column width="33%" .fragment}
Os resgistradores são importantes por causa da [multiplexação de tempo da CPU.]{.marked}
:::
::::

## Revisão sobre hardware de computadores

\

:::: columns
::: {.column width="30%"}

### Memória 
> *É o segundo principal componente em qualquer computador, o qual deve ser rápido ao extremo (mais rápida do que executar uma instrução, de maneira que a CPU não seja atrasada pela memória).*
:::
::: {.column width="70%"}

\

![](images/tanenbaum-01-09.png)
:::
::::

## Memória

:::: {.columns}
::: {.column width="25%" .fragment}
A camada superior consiste em [registradores internos]{.blue} à CPU. Eles são feitos do mesmo material que a CPU e são, desse modo, tão rápidos quanto ela
:::
::: {.column width="25%" .fragment}
[Memória cache]{.blue} é uma parte da CPU. Atua como memória temporária para que seja recuperado rapidamente os dados, sem a necessidade de uma busca direta na memória principal
:::
::: {.column width="25%" .fragment}
[Mémoria principal]{.blue} tem por finalidade o armazenamento de instruções e dados de programas que serão ou estão sendo executados pela CPU.
:::
::: {.column width="25%" .fragment}
[Discos magnéticos]{.blue} são um tipo de memória não volátil de grande capacidade de armazenamento, usada para guardar informações (instruções e dados de programas) que não serão imediatamente usadas pela CPU.
:::
::::

## Exemplo de utilização de cache

\

:::: columns
::: {.column width="30%" .fragment}
[DuckDB]{.blue} tem uma forma de consulta (*vectorized or just-in-time query execution engines*) que [são processadas em lotes de dados que consistem em coleções de vetores]{.marked}, cada um contendo uma quantidade fixa de valores das colunas.
:::

::: {.column width="30%" .fragment}
O resultado é um uso eficiente das operações no cache, [mantendo os dados nas consultas tanto quanto possível no [cache L1 e L2]{.blue}]{.marked} muito rápido.
:::
::: {.column width="40%" .fragment}
![Fonte: [blog.min.io/duckdb-and-minio-for-a-modern-data-stack/](https://blog.min.io/duckdb-and-minio-for-a-modern-data-stack/)](images/caches.jpeg)
:::
::::

## O zoológico dos sistemas operacionais

- Sistemas operacionais de computadores de grande porte, [de alto desempenho e alta disponibilidade]{.marked} (*mainframes*)
- Sistemas operacionais de servidores
- Sistemas operacionais de computadores pessoais
- Sistemas operacionais de computadores portáteis
- Sistemas operacionais embarcados
- Sistemas operacionais de tempo real

## Conceitos de sistemas operacionais

- [**Processos:**]{.blue} [um processo é basicamente um [programa em execução]{.blue}]{.marked} e associado a cada processo está um [espaço de endereçamento]{.blue}, uma lista de posições de mémoria que vai de 0 a algum máximo, onde o processo pode ler e escrever.
- [**Espaços de endereçamento:**]{.blue} diz respeito ao gerenciamento e à [proteção da memória principal do computador]{.marked}, quando se tem multiplos processos sendo executados.
- [**Arquivos:**]{.blue} um sistema de arquivos é uma estrutura usada por um sistema operacional para organizar e gerenciar arquivos em um dispositivo de armazenamento. [Chamadas do sistemas são necessárias para criar, remover, ler escrever arquivos.]{.marked} Existe o conceito de [diretório]{.blue} como uma maneira de agrupar os arquivos

## Conceitos de sistemas operacionais

- [**Entrada/Saída:**]{.blue} o sistema operacional tem um subsistema de E/S para [gerenciamento dos dispositivos]{.marked}.
- [**Proteção:**]{.blue} o sistema operacional [gerencia a segurança
do sistema]{.marked} de maneira que os arquivos, por exemplo,
sejam acessíveis somente por usuários autorizados.
- [**Interpretador de comandos (shell):**]{.blue} é a principal interface entre um usuário e o sistema operacional.

## Conceitos de sistemas operacionais

> *[Memória virtual:]{.blue} A memória virtual proporciona a [capacidade de executar programas maiores do que a memória física da máquina]{.marked}, rapidamente movendo pedaços entre a memória RAM e o disco.*

\

Quando se instala o linux é possível definir o [tamanho da partição do disco que será utilizado pela memória virtual (swap)]{.marked}.

```{.bash code-line-numbers="false"}
free
```
```
              total        used        free      shared  buff/cache   available
Mem:        13290480      480388    10480984        1252     2329108    12527384
Swap:              0           0           0
```

## Chamadas de sistema

Já vimos que os sistemas operacionais apresentam duas funções: abstrações para os usuários [e gerenciamento de recursos.]{.fragment  fragment-index=1 .semi-fade-out}

::: {.fragment fragment-index=1}
- A parte do [gerenciamento de recursos]{.blue} fica [transparente para os usuários]{.marked} e é feita automaticamente.
:::
::: {.fragment fragment-index=2}
- Na sua maior parte a interação entre programas de usuários e o sistema operacional lida com as [abstrações]{.blue}.
:::

## Chamadas de sistema

\

:::: columns
::: {.column width="60%"}
![A manipulação de uma aplicação de usuário que invoca a chamada de sistema `open()`](images/silberschatz-02-06.png)
:::
::: {.column width="40%"}
1. A função `open()` é executada em [modo usuário]{.blue}
2. No [modo núcleo/kernel]{.blue} é feita uma busca em um vetor de endereços a implementação da chamada `open()`
3. O `open()` é executado e [retorna o resultado]{.marked} para o sistema operacional e sequencialmente para o usuário
:::
::::

## Chamadas de sistema

> API: *elemento que proporciona uma ligação física ou lógica entre dois sistemas ou partes de um sistema que não poderiam ser conectados diretamente.*

- API define um [conjunto de normas que possibilita a comunicação]{.marked} entre plataformas por meio de uma série de padrões e protocolos.
- Por meio de APIs, desenvolvedores podem criar novos softwares e aplicativos capazes de se comunicar com outras plataformas. Por exemplo: [caso um desenvolvedor queira criar um aplicativo de fotos para Android, ele poderá ter acesso à câmera do celular através da API do sistema operacional, sem ter a necessidade de criar uma nova interface de câmera do zero.]{.marked}. 

\

*Aqui uma abstração da complexidade!*

## Chamadas de sistema

> *As chamadas de sistema sempre foram o meio pelo qual os programas de [espaço do usuário]{.blue} podem acessar os [serviços do kernel]{.blue}*

<center>

```{mermaid}
flowchart LR;
    subgraph U["Usuário"]
    A(Função <br> mkdir) --> B[Interface de Chamada de Sistema <br> sys_mkdir];
    end
    subgraph K["Kernel"]
    B --> C[Manipulador de <br> Chamada de Sistema];
    end

    style U fill:#ffffff
    style K fill:#e4e4e4
```
</center>

:::: columns
::: {.column}

- Cria um novo diretório (pasta)
```{.bash code-line-numbers="false"}
mkdir mynewdir
```
- Visualizar a interface de chamada
```{.bash code-line-numbers="false"}
cat /usr/include/asm*/unistd.h | grep -B 1 sys_mkdir
```
```
#define __NR_mkdirat 34
__SYSCALL(__NR_mkdirat, sys_mkdirat)
```
:::
::: {.column}

- Visualizar os registradores onde são armazenados as info da chamada
```{.bash code-line-numbers="false"}
cpuid -1 -r | head -3
```
```
CPU:
   0x00000000 0x00: eax=0x0000000d ebx=0x756e6547 ecx=0x6c65746e edx=0x49656e69
   0x00000001 0x00: eax=0x000406f0 ebx=0x01020800 ecx=0xfefa3203 edx=0x1f8bfbff
```
:::
::::

## Chamadas de sistema

Uma chamada de sistem pode necessitar de outras chamadas serem realizadas

```{.bash code-line-numbers="false"}
strace -c mkdir mynewdir
```

```
% time     seconds  usecs/call     calls    errors syscall
------ ----------- ----------- --------- --------- ----------------
  0.00    0.000000           0         5           read
  0.00    0.000000           0         8           close
  0.00    0.000000           0        18           mmap
  0.00    0.000000           0         7           mprotect
  0.00    0.000000           0         1           munmap
  0.00    0.000000           0         3           brk
  0.00    0.000000           0         4           pread64
  0.00    0.000000           0         2         2 access
  0.00    0.000000           0         1           execve
  0.00    0.000000           0         1           mkdir
  0.00    0.000000           0         2         2 statfs
  0.00    0.000000           0         2         1 arch_prctl
  0.00    0.000000           0         1           set_tid_address
  0.00    0.000000           0        26        20 openat
  0.00    0.000000           0        26        20 newfstatat
  0.00    0.000000           0         1           set_robust_list
  0.00    0.000000           0         1           prlimit64
  0.00    0.000000           0         1           getrandom
  0.00    0.000000           0         1           rseq
------ ----------- ----------- --------- --------- ----------------
100.00    0.000000           0       111        45 total
```

## Chamadas de sistema

\

:::: columns
::: {.column width="33%" .fragment}
Os desenvolvedores de aplicações projetam programas de acordo com uma interface de programação de aplicações (API — application programming interface).


:::
::: {.column width="33%" .fragment}
[A API especifica um conjunto de funções que estão disponíveis para um programador de aplicações,]{.marked} incluindo os parâmetros que são passados a cada função e os valores de retorno que o programador pode esperar.

:::
::: {.column width="33%" .fragment}
[*Portable Operating System Interface*]{.blue} (POSIX) é uma API para o sistema UNIX/Linux.
:::
::::

::: {.fragment}
*Se usarmos o comando `ps`, ele deverá se comportar da mesma forma no OpenBSD, Debian e macOS.*
:::

## Chamadas de sistema

\

:::: columns
::: {.column}

- Uso da função `write` em `C++`

```{.cpp filename="write.cpp" code-line-numbers="1|3-6"}
#include<unistd.h>

int main() 
{
    write(1, "Ola Mundo!", 10);
}
```
:::
::: {.column}
- Nas linguagens de programação C e C++, `unistd.h` é o nome do arquivo de cabeçalho que fornece acesso à API do sistema operacional [POSIX]{.blue}.
- Compilar: `g++ write.cpp`
- Executar: `./a.out`
:::
::::

## Chamada de sistema

\

Abaixo a chamada de sistema `write` sendo utilizada

```{.bash code-line-numbers="false"}
strace -o trace.txt ./a.out

cat trace.txt | grep -A 5 write
```
```
write(1, "Ola Mundo!", 10)              = 10
exit_group(0)                           = ?
+++ exited with 0 +++
```

## Chamada de sistema

\

No fim das contas um `printf` realiza a mesma chamada de sistema `write`

:::: columns
::: {.column}
```{.cpp filename="write.cpp" code-line-numbers="1|3-6"}
#include<stdio.h>

int main() 
{
    printf("Ola Mundo!");
}
```
:::
::: {.column}
```{.bash code-line-numbers="false"}
strace -o trace.txt ./a.out

cat trace.txt | grep -A 5 write
```
```
write(1, "Ola Mundo!", 10)              = 10
exit_group(0)                           = ?
+++ exited with 0 +++
```
:::
::::

## Chamada de sistema

\

```{.bash code-line-numbers="false"}
strace -o trace.txt python -c 'print("Ola Mundo!")'

cat trace.txt | grep -A 5 write 
```

- Será realizada a chamada de sistema `write`?
- Comparar com as chamadas de sistema feitas com `C++`

## Chamadas de sistema

- Chamadas de sistema para gerenciamento de processos
- Chamadas de sistema para gerenciamento de arquivos
- Chamadas de sistema para gerenciamento de diretórios
- Chamadas de sistema diversas

## Chamadas de sistema para gerenciamento de processos 

\

| Chamada                                | Descrição                                       |
|----------------------------------------|-------------------------------------------------|
| `pid = fork()`                         | Criar um processo filho idêntico ao pai         |
| `pid = waitpid(pid, statloc, options)` | Espera que um processo filho seja concluído     |
| `s = execve(name, argv, environp)`     | Substitui a imagem do núcleo de um processo     |
| `exit(status)`                         | Conclui a execução do processo e devolve status |


## Chamadas de sistema para gerenciamento de processos 
### `fork`

::: {.panel-tabset}
### Python
```{.python filename="fork_exemplo.py" code-line-numbers="|1|4|6-7|9|11-12"}
import os
import sys

pid = os.fork()

if pid < 0:
  sys.exit("Fork fail")

print(f"Hello world!, process_id(pid) = {os.getpid()}\n")

# Hello world!, process_id(pid) = 7534
# Hello world!, process_id(pid) = 7536
```

### C++
```{.cpp filename="fork_exemplo.cpp" code-line-numbers="|2|6|11|15-16"}
#include <stdio.h>
#include <unistd.h>

int main()
{
	pid = fork();
	if(pid < 0){
	perror("Fork fail");
	_exit(1);
	}
	printf("Hello world!, process_id(pid) = %d \n", getpid());
	return 0;
}

// Hello world!, process_id(pid) = 685 
// Hello world!, process_id(pid) = 686
```
:::

## Chamadas de sistema para gerenciamento de processos 
### `waitpid`

::: {.panel-tabset}

### Python
```{.python filename="waitpid_exemplo.py" code-line-numbers="|1|3-5|7|8-11|12-13"}
import os

i = 1
waitpid_return = ()
print(f"process_id(pid) parent= {os.getpid()}\n")

pid = os.fork()
if pid > 0:
  for i in range(1, 6):
    waitpid_return = os.waitpid(pid, os.WNOHANG)
    print(f"{i}, process_id(pid) child = {pid}, waitpid = {waitpid_return}\n")
else:
  print(f"{i}, process_id(pid) child = {pid}, waitpid = {waitpid_return}\n")
```

### C++
```{.cpp filename="waitpid_exemplo.cpp" code-line-numbers="1-6|9-10|13-16|18-21"}
#include <stdio.h>
#include <unistd.h>
#include <sys/wait.h>
int i = 1;
int pid;
int waitpid_return;
int main ()
{   
    printf("process_id(pid) parent= %d\n", getpid());
    pid = fork();
    if (pid != 0)
    {   
      
      for (int i = 1; i < 5; i++) {
        waitpid_return = waitpid(pid, NULL, WNOHANG);
        printf("%d, process_id(pid) child = %d, waitpid = %d\n", i, pid, waitpid_return);
      }
    }
    else {
        waitpid_return = waitpid(pid, NULL, WNOHANG);
        printf("%d, process_id(pid) child = %d, waitpid = %d\n", i, pid, waitpid_return);}
        return 0;
    }
```
:::

## Chamadas de sistema para gerenciamento de processos 
### `execve`

::: {.panel-tabset}
### C++
```{.cpp filename="execve.cpp"}
#include <unistd.h>
#include <iostream>
#include <string>

std::string c = "/bin/ls";
std::string p = "-lh";
char *args[] = {c.data(), p.data()};
int main() {
  execve(args[0], args, NULL);
}

```
:::

## Chamadas de sistema para gerenciamento de diretórios

\

| Chamada                          | Descrição                                       |
|----------------------------------|-------------------------------------------------|
| `s = mkdir(name, mode)`          | Cria um novo diretório                          |
| `s = rmdir(name)`                | Remove um diretório                             |
| `s = link(name1, name2)`         | Cria um nova entrada name1 apontando para name2 |
| `s = unlink(name)`               | Remove uma entrada de diretório                 |
| `s = mount(special, name, flag)` | Monta um sistema de arquivos                    |
| `s = unmount(special)`           | Desmonta um sistema de arquivos                 |

## Chamadas de sistema para gerenciamento de diretórios

### Exemplos

```{.bash code-line-numbers="false"}
# Criar um novo diretório
mkdir mynewdir

# Remover um diretório
rmdir mynewdir

# Criar link entre arquivos
link myfile1 myfile2

# Criar link simbólico (atalho)
ln -s myfile1 myfile2

```

## Alguns comandos úteis

\

```{.bash code-line-numbers="false"}
# Acessar o manual de um comando
man mkdir

# Criar um novo diretório
mkdir novapasta

# Criar um novo diretório contendo outro diretório (pasta)
mkdir -p novapasta/outrapasta

# Criar um diretório com alguma permissão definida
mkdir -m 700 novapasta

# Remover um diretório vazio
rmdir novapasta
```

## Alguns comandos úteis

\

```{.bash code-line-numbers="false"}
# Criar um arquivo em branco
touch meuarquivo.txt

# Criar um arquivo com algum conteúdo
echo "Ola mundo!" > meuarquivo.txt

# Adicionar uma nova linha a um arquivo existente
echo "Nova linha" >> meuarquivo.txt 

# Remover um arquivo
rm meuarquivo.txt

# Remover um diretório
rm -r novapasta
```

## Alguns comandos úteis

\

```{.bash code-line-numbers="false"}
# Mover arquivos
mv meuarquivo.txt /outrapasta

# Renomear arquivos
mv meuarquivo.txt novonome.txt

# Copiar arquivos
cp meuarquivo.txt copiadoarquivo.txt

# Copiar diretórios
cp -r meudiretorio outro/lugar
```

## Chamadas de sistema para gerenciamento diversos

\

| Chamada                    | Descrição                                |
|----------------------------|------------------------------------------|
| `s = chdir(dirname)`       | Altera o diretório de trabalho           |
| `s = chmod(name, mode)`    | Altera os bits de proteção de um arquivo |
| `s = kill(pid, signal)`    | Envia um sinal para um processo          |

## Chamadas de sistema para gerenciamento diversos

### Exemplos

```{.bash code-line-numbers="false"}
# Alterar um diretório (geralmente se usa cd)
chdir <diretório existente>
cd <diretório existente>

# Define a proteção de um arquivo
chmod 700 myfile

# "Matar" um processo
kill <pid>
```

## Proteção de um arquivo

Devo utilizar um valor octal para *usuário/grupo/outros*

| Octal | Binário | Código de Proteção                 |     |
|-------|---------|------------------------------------|-----|
| 0     | 000     | Nenhuma permissão                  |`---`|          
| 1     | 001     | Permissão de execução              |`--x`|
| 2     | 010     | Permissão de escrita               |`-w-`|
| 3     | 011     | Permissão de escrita e execução    |`-wx`|
| 4     | 100     | Permissão de leitura               |`r--`|
| 5     | 101     | Permissão de leitura e execução    |`r-x`|
| 6     | 110     | Permissão de leitura e escrita     |`rw-`|
| 7     | 111     | Todas as permissões                |`rwx`|

```{.bash code-line-numbers="false"}
# Permissão de escrita para o usuário (2) e nenhuma permissão para o grupo (0) e outros (0)
chmod 200 myfile
ls -l myfile
```
```
--w-------  1 thop  staff  0 27 Mar 16:18 myfile
```

```{.bash code-line-numbers="false"}
# Permissão de leitura/escrita para o usuário (6) e permissão de leitura para o grupo (4)
chmod 640 myfile
ls -l myfile
```
```
-rw-r-----  1 thop  staff  0 27 Mar 16:18 myfile
```

# Estruturas do Sistema Operacional

> *Os sistemas operacionais podem ser organizados de várias maneiras, dependendo de sua estrutura interna e de como eles gerenciam os recursos do computador.*

## Monolítico

\

- Nesta estrutura, todo o sistema operacional [é implementado como um único programa de grande porte]{.marked}.
- Todas as funcionalidades do sistema operacional, como gerenciamento de memória, gerenciamento de processos e sistemas de arquivos, residem no kernel.
- Exemplos [incluem sistemas operacionais mais antigos]{.marked}, como MS-DOS e versões mais antigas do UNIX.

## Microkernel

\

- Neste modelo, o kernel é mínimo e [fornece apenas as funcionalidades básicas]{.marked}, como gerenciamento de memória, comunicação entre processos e escalonamento de CPU.
- Funcionalidades adicionais, como sistemas de arquivos e drivers de dispositivos, são implementadas como processos de usuário que se comunicam com o kernel.
- Exemplos incluem o MINIX e o Symbian.

*Desse modo, um erro no driver de áudio fará que o som fique truncado ou pare, [mas não derrubará o computador.]{.marked}*

## Híbrido

\

- Esta abordagem combina elementos do [kernel monolítico e do microkernel]{.blue}.
- [O kernel contém algumas funcionalidades essenciais,]{.marked} como gerenciamento de memória e escalonamento de processos, enquanto outras funcionalidades são implementadas como módulos do kernel ou como processos de usuário.
- Exemplos incluem Linux, Windows NT/2000/XP/Vista/7/8/10.

## Sistemas Virtuais

\

- Esta estrutura cria uma máquina virtual que [simula uma arquitetura de hardware]{.marked} para cada processo.
- Cada processo tem a ilusão de que possui seu próprio sistema operacional.
- Exemplos incluem máquinas virtuais como VMware, VirtualBox e Hyper-V.

![(a) Um hipervisor de tipo 1. (b) Um hipervisor de tipo 2 na prática. Uma discussão sobre a diferença entre hipervisors 1 e 2: <https://aws.amazon.com/pt/compare/the-difference-between-type-1-and-type-2-hypervisors/>](images/tanenbaum-01-29.png){height="250"}

# Gerenciamento de processos

> *O conceito mais central em qualquer sistema operacional é o processo: [uma abstração de um programa em execução.]{.marked}*

## Contador de Programa e Registrador de Instruções 

\

:::: columns
::: {.column}
- [Contador de Programa (*Program Counter*)]{.blue}, é um registrador de propósito especial usado pelo processador para [armazenar o endereço da próxima instrução]{.marked} a ser executada.
- [Registrador de Instruções (*Instruction Register*)]{.blue} contém a [instrução que está sendo executada]{.marked} pela CPU

![Ciclo de instrução básico](images/stallings-03-03.png){width="90%"}

:::
::: {.column}
Início da execução do programa:

1. O [Contador de Programa]{.blue} contém 0x00000000 (digamos que este seja o endereço de início do programa na memória).
2. A instrução é buscada na memória e colocada no [Registrador de Instruções]{.blue}.
3. A instrução é executada.
4. Agora é hora de avançar para o próximo endereço de instrução, e seguir o mesmo processo (ciclo de intrução)
:::
::::

## Contador de Programa e Registrador de Instruções 

\

<center>![](images/von-neumann-architecture.jpeg)</center>

## Processos

- Um processo [é apenas uma instância de um programa em execução]{.marked}, incluindo os valores atuais do contador do programa, registradores e variáveis.
- Processos podem ser criados e terminados dinamicamente.
- Cada processo tem seu próprio [espaço de endereçamento]{.blue}.

## O modelo de processo

:::: columns
::: {.column width="50%"}
a. Vemos um computador multiprogramando quatro programas na memória (com contador programa físico).
b. Vemos quatro processos, cada um com seu próprio fluxo de controle e sendo executado independente dos outros (contador de programa lógico). 
c. Vemos que, analisados durante um intervalo longo o suficiente, todos os processos tiveram progresso, mas a qualquer dado instante apenas um está sendo de fato executado.
:::
::: {.column width="50%%"}

\

<center>![](images/tanenbaum-02-01.jpg)</center>

> *Em qualquer sistema de multiprogramação, [a CPU muda de um processo para outro rapidamente, executando cada um por dezenas ou centenas de milissegundos]{.marked}, dando a ilusão do [paralelismo]{.blue}.*
:::
::::

## Criação de processos

> *Sistemas operacionais precisam de alguma maneira criar processos.*

Quatro eventos principais fazem com que os processos sejam criados:

:::: columns
::: {.column width="25%" .fragment}
[Inicialização do sistema]{.blue}. Alguns processos são de (1) primeiro plano, sendo processos que interagem com o usuário; (2) segundo plano, processos que não estão associados a um usuário (*daemons*)
:::
::: {.column width="25%" .fragment}
[Execução de uma chamada de sistema]{.blue} de criação de processo por um processo em execução. [Um processo em execução emitirá chamadas de sistema para criar processos novos para ajudá-lo em seu trabalho]{.marked}
:::
::: {.column width="25%" .fragment}
[Solicitação de um usuário]{.blue} para criar um novo processo. Em sistemas interativos, os usuários podem começar um programa [digitando um comando ou clicando duas vezes]{.marked} sobre um ícone.
:::
::: {.column width="25%" .fragment}
Início de uma [tarefa em lote]{.blue}. *Pense no gerenciamento de estoque ao fim de um dia em uma cadeia de lojas, nesse caso usuários podem submeter tarefas em lote ao servidor (possivelmente de maneira remota).*
:::
::::

## Criação de processos

:::: columns
::: {.column width="40%"}
No UNIX, há apenas uma chamada de sistema para criar um novo processo: [fork]{.blue}. [Essa chamada cria um clone exato do processo que a chamou.]{.marked} Após a fork, os dois processos, o pai e o filho, têm a mesma imagem de memória, as mesmas variáveis de ambiente e os mesmos arquivos abertos. Mas atuam de forma independente.
:::
::: {.column width="60%"}
Como identificar processos filho?

```{.bash filename="child.sh"}
#!/bin/bash
sleep infinity
```

```{.bash filename="parent.sh"}
#!/bin/bash
./child.sh &
sleep infinity
```

```{.bash filename="$"}
parent.sh &
```

Usando:
```{.bash filename="$"}
pgrep -P <parent pid>
pgrep -lP <parent pid>
pstree -p <parent pid>
ps --ppid <parent pid>
ls /proc/<parent pid>/task
cat /proc/<parent pid>/task/<parent pid>/children
```
:::
::::

## Término de processos

:::: columns
::: {.column}
Após um processo ter sido criado, ele começa a ser executado e realiza qualquer que seja o seu trabalho. *No entanto, nada dura para sempre, nem mesmo os processos.* Cedo ou tarde, o novo processo terminará, normalmente devido a uma das condições a seguir:

1. Saída normal (voluntária).
2. Erro fatal (involuntário).
3. Saída por erro (voluntária).
4. Morto por outro processo (involuntário).
:::
::: {.column}
Exemplos:

1. `ctrl + c` para interromper programas ou processos no primeiro plano
2. `!g++ foo.cpp` e `foo.cpp` não existe no diretório
3. Um Erro interno do processo que afeta seu funcionamento, então o usuário é avisado e o programa termina
4. `kill <pid>`
:::
::::

## Hierarquias de processos

:::: columns
::: {.column}
- Em alguns sistemas, quando um processo cria outro, o processo pai e o processo filho continuam a ser associados de certas maneiras. 
- O processo filho pode em si criar mais processos, formando uma hierarquia de processos.

```{filename="$"}
./grandparent.sh
ps -efj | egrep "PGID|children|parent"
kill -9 -<pgid>
```
:::
::: {.column}
```{.bash filename="grandparent.sh"}
#!/bin/bash
bash parent.sh &
bash parent.sh &
for i in {1..100}; do 
sleep 2; 
echo -n "This is the grandparent process $i"; 
done
```

```{.bash filename="parent.sh"}
#!/bin/bash
bash children.sh &
bash children.sh &
for i in {1..100}; do sleep 2; echo -n "This is the parent process $i"; 
done
```

```{.bash filename="children.sh"}
#!/bin/bash
for i in {1..100}; do 
sleep 2; 
echo -n "This is a test in children process $i"; 
done
```
:::
::::

## Estados de processos

\

:::: columns
::: {.column width="60%"}
- Embora cada processo seja uma entidade independente, com seu próprio contador de programa e estado interno, processos muitas vezes precisam interagir entre si.
- Um processo pode gerar alguma saída que outro processo usa como entrada.

\

```{filename="$"}
curl -s https://openbible.com/textfiles/kjv.txt | \
grep "Exodus\s2" | \
head -4
```

:::
::: {.column width="40%"}
São 3 Estados:

- [Em execução]{.blue} (realmente usando a CPU naquele instante).
- [Pronto]{.blue} (executável, temporariamente parado  para deixar outro processo ser executado).
- [Bloqueado]{.blue} (incapaz de ser executado até que algum evento externo aconteça).
:::
::::

## Estados de processos

\

:::: columns
::: {.column}
1. O processo é [bloqueado]{.blue} aguardando uma entrada
2. O escalonador [seleciona outro]{.blue} processo
3. O escalonador [seleciona esse]{.blue} processo
4. A entrada torna-se [disponível]{.blue}
:::
::: {.column}
![Um processo pode estar nos estados em execução, bloqueado ou pronto. Transições entre esses estados ocorrem como mostrado.](images/tanenbaum-02-02.png){width="80%"}
:::
::::

## Estados de processos

O nível mais baixo de um sistema operacional estruturado em processos controla interrupções e escalonamento. Acima desse nível estão processos sequenciais. 

<center>![](images/tanenbaum-02-03.png){height="300"}</center>

> *O [escalonamento]{.blue}, isto é, [decidir qual processo deve ser executado, quando e por quanto tempo, é um assunto importante;]{.marked} nós o examinaremos mais adiante neste capítulo. Muitos [algoritmos]{.blue} foram desenvolvidos para tentar [equilibrar as demandas concorrentes de eficiência para o sistema como um todo e justiça para os processos individuais.]{.marked}*

## Implementação de processos

> *Para implementar o modelo de processos, o sistema operacional mantém uma tabela (um arranjo de estruturas) chamada de [tabela de processos]{.blue}, com uma entrada para cada um deles.*

:::: columns
::: {.column width="40%"}
- Essas entradas contêm informações importantes sobre o [estado do processo]{.blue} quando ele é [trocado do estado em execução para pronto ou bloqueado]{.marked}
- Podendo o processo [retornar precisamente para o mesmo estado em que se encontrava antes de ser interrompido.]{.marked}
:::
::: {.column width="60%"}
![Alguns dos campos de uma entrada típica na tabela de processos](images/tanenbaum-02-04.png)
:::
::::

# Scheduling de Processos

## Scheduling de Processos

\

:::: columns
::: {.column width="33%" .fragment}
O objetivo da multiprogramação é haver [sempre algum processo em execução para maximizar a utilização da CPU.]{.marked}
:::
::: {.column width="33%" .fragment}
O compartilhamento de tempo é [alternar a CPU entre os processos, com tanta frequência]{.marked}, que os usuários possam interagir com cada programa enquanto ele está sendo executado.
:::
::: {.column width="33%" .fragment}
Para alcançar esses objetivos, [o scheduler de processos seleciona um processo disponível]{.marked} (possivelmente em um conjunto de vários processos disponíveis) para execução na CPU.
:::
::::

## Scheduling de Processos

Cada processo é representado, no sistema operacional, por um bloco de controle de processo (PCB - *process control block*) - também chamado bloco de controle de tarefa.

:::: columns
::: {.column width="20%" .fragment}
[Estado do processo]{.blue} pode ser novo, pronto, em execução, em espera, parado, e assim por diante.
:::
::: {.column width="20%" .fragment}
[Contador do programa.]{.blue} indica o endereço da próxima instrução a ser executada para esse processo.
:::
::: {.column width="20%" .fragment}
[Registradores da CPU]{.blue} incluem acumuladores, registradores índice, ponteiros de pilhas e registradores de uso geral, além de qualquer informação do código de condição.
:::
::: {.column width="20%" .fragment}
[Informações de scheduling da CPU]{.blue} incluem a prioridade de um processo, ponteiros para filas de scheduling e quaisquer outros parâmetros de scheduling.
:::
::: {.column width="20%" .fragment}
[Informações de gerenciamento da memória]{.blue} podem incluir itens como o valor dos registradores base e limite e as tabelas de páginas, ou as tabelas de segmentos.
:::
::::

## Fila de scheduling

:::: columns
::: {.column}
Quando os processos entram no sistema, eles são inseridos em uma [fila de *jobs* que é composta por todos os processos no sistema]{.marked}. Os processos que estão residindo na memória principal e estão prontos e esperando execução são mantidos em uma lista chamada fila de prontos.
:::
::: {.column}
![](images/silberschatz-03-04.png)
:::
::::

## Mudança de contexto

\

> *[A alocação da CPU a outro processo requer a execução do salvamento do estado]{.marked} do processo corrente e a restauração do estado de um processo diferente. Essa tarefa é conhecida como [mudança de contexto]{.blue}*

\

- As interrupções fazem com que o sistema operacional tire a CPU de sua tarefa corrente para executar uma rotina do kernel.
- Essas operações ocorrem, com frequência, em sistemas de uso geral. 
- O contexto é representado no PCB do processo.

## Mudança de contexto

\

O tempo gasto na mudança de contexto é puro [*overhead*]{.blue} porque o sistema não executa trabalho útil durante a permuta de processos. [A velocidade da permuta varia de uma máquina para outra, dependendo da velocidade da memória, do número de registradores a serem copiados]{.marked}

## Comunicação Interprocessos

\

> *Os processos que são executados concorrentemente no sistema operacional podem ser [processos independentes]{.blue} ou [processos cooperativos]{.blue}*

\

:::: columns
::: {.column}
[Um processo é [independente]{.blue} quando não pode afetar outros processos em execução]{.marked} no sistema nem ser afetado por eles. Qualquer processo que não compartilhe dados com outros processos é independente.
::: 
::: {.column}
[Um processo é [cooperativo]{.blue} quando pode afetar outros processos em execução no sistema ou pode ser afetado por eles.]{.marked} É claro que qualquer processo que compartilhe dados com outros processos é um processo cooperativo.
::: 
::::

## Comunicação Interprocessos

\

Razões para o fornecimento de um ambiente que permita a cooperação entre processos:

:::: columns
::: {.column width="25%"}
[Compartilhamento de informações.]{.blue} Já que vários usuários podem estar interessados no mesmo bloco de informações (por exemplo, um arquivo compartilhado), devemos fornecer um ambiente que permita o acesso concorrente.
:::
::: {.column width="25%"}
[Aumento da velocidade de computação.]{.blue} Se quisermos que uma tarefa em particular seja executada mais rapidamente, devemos dividi-la em subtarefas a serem executadas em paralelo.
:::
::: {.column width="25%"}
[Modularidade.]{.blue} Podemos querer construir o sistema de forma modular, dividindo suas funções em processos
:::
::: {.column width="25%"}
[Conveniência.]{.blue} Até mesmo um usuário individual pode trabalhar em muitas tarefas ao mesmo tempo. Por exemplo, um usuário pode editar, ouvir música e compilar em paralelo.
:::
:::: 

## Processos cooperativos

\

Processos cooperativos demandam um mecanismo de comunicação entre processos (IPC) que lhes permita trocar dados e informações. Há dois modelos básicos de comunicação entre processos: [memória compartilhada e transmissão de mensagens]{.blue}.

:::: columns
::: {.column width="33%"}
No modelo de [memória compartilhada]{.blue}, estabelece-se uma região da memória que é compartilhada por processos cooperativos. Os processos podem, então, trocar informações lendo e gravando dados na região compartilhada.
:::
::: {.column width="33%"}
No modelo de [transmissão de mensagens]{.blue}, a comunicação ocorre por meio de mensagens trocadas entre os sistemas cooperativos. 
:::
::: {.column width="33%"}
![](images/silberschatz-03-12.png)
:::
::::

## Sistema de memória compartilhada

\

A comunicação entre processos que usam memória compartilhada [requer que os processos em comunicação estabeleçam uma região de memória compartilhada.]{.marked} Normalmente, a região de memória compartilhada reside no espaço de endereçamento do processo que cria o segmento de memória compartilhada. Outros processos que queiram se comunicar usando esse segmento de memória compartilhada devem anexá-lo ao seu espaço de endereçamento. 

## Sistema de memória compartilhada

\

### Condições de corrida

:::: columns
::: {.column}
Em alguns sistemas operacionais, processos que estão trabalhando juntos podem compartilhar de alguma memória comum que cada um pode ler e escrever.
:::
::: {.column}
![](images/tanenbaum-02-21.png)

Veja na figura dois processos querem acessar a memória compartilhada ao mesmo tempo.
:::
::::

## Sistema de memória compartilhada

\

### Regiões críticas

:::: columns
::: {.column}
[Como evitar as condições de corrida?]{.marked} A chave para evitar problemas aqui e em muitas outras situações envolvendo memória compartilhada, arquivos compartilhados e tudo o mais compartilhado é encontrar alguma maneira de [proibir mais de um processo de ler e escrever os dados compartilhados ao mesmo tempo.]{.marked}
:::
::: {.column}
Colocando a questão em outras palavras, o que precisamos é de [exclusão mútua]{.blue}, isto é, alguma maneira de se certificar de que [se um processo está usando um arquivo ou variável compartilhados, os outros serão impedidos de realizar a mesma coisa.]{.marked}

![](images/tanenbaum-02-22.png)

:::
::::

## Regiões críticas

\

[Quatro condições são estabelecidas]{.marked} para se chegar a uma boa solução de corridas:

1. Dois processos jamais podem estar simultaneamente dentro de suas regiões críticas.
2. Nenhuma suposição pode ser feita a respeito de velocidades ou do número de CPUs.
3. Nenhum processo executando fora de sua região crítica pode bloquear qualquer processo.
4. Nenhum processo deve ser obrigado a esperar eternamente para entrar em sua região crítica.

## Exclusão mútua com espera ocupada

### Desabilitando interrupções

:::: columns
::: {.column}
[Com as interrupções desabilitadas, nenhuma interrupção de relógio poderá ocorrer.]{.marked} Afinal de contas, a CPU só é chaveada de processo em processo em consequência de uma interrupção de relógio ou outra, e com as interrupções desligadas, a CPU não será chaveada para outro processo. [Então, assim que um processo tiver desabilitado as interrupções, ele poderá examinar e atualizar a memória compartilhada]{.marked} sem medo de que qualquer outro processo interfira.
:::
::: {.column}
Contudo, em um sistema multinúcleo (isto é, sistema de multiprocessador) [desabilitar as interrupções de uma CPU não evita que outras CPUs interfiram com as operações que a primeira está realizando.]{.marked} Em consequência, esquemas mais sofisticados são necessários.
:::
::::

## Exclusão mútua com espera ocupada

### Variáveis do tipo trava

:::: columns
::: {.column}
Considere ter uma única variável (de trava) compartilhada, inicialmente 0. [Quando um processo quer entrar em sua região crítica, ele primeiro testa a trava. Se a trava é 0, o processo a configura para 1 e entra na região crítica.]{.marked} *Se a trava já é 1,o processo apenas espera até que ela se torne 0.* Desse modo, um 0 significa que nenhum processo está na região crítica, e um 1 significa que algum processo está em sua região crítica.
:::
::: {.column}
Infelizmente, essa ideia contém exatamente a mesma falha fatal que vimos no diretório de spool. Suponha que um processo lê a trava e vê que ela é 0. Antes que ele possa configurar a trava para 1, outro processo está escalonado, executa e configura a trava para 1. Quando o primeiro processo executa de novo, ele também configurará a trava para 1, e [dois processos estarão nas suas regiões críticas ao mesmo tempo.]{.marked}
:::
::::

## Exclusão mútua com espera ocupada

### Alternância explícita

:::: columns
::: {.column}
A variável do tipo inteiro `turn`, inicialmente 0, serve para controlar de quem é a vez de entrar na região crítica e examinar ou atualizar a memória compartilhada. Inicialmente, o processo 0 inspeciona `turn`, descobre que ele é 0 e entra na sua região crítica. O processo 1 também encontra lá o valor 0 e, portanto, espera em um laço fechado testando continuamente turn para ver quando ele vira 1. Testar continuamente uma variável até que algum valor apareça é chamado de espera ocupada.
:::
::: {.column}

```{.python}
while True:
  while turn != 1:
    print("processo 0 na região crítica")
    turn = 1
    print("processo 0 na região não crítica")

while True:
  while turn != 0:
    print("processo 1 na região crítica")
    turn = 0
    print("processo 1 na região não crítica")
```

Digamos que em algum momento os dois processos estão em suas regiões não críticas e o processo 0 colocar `turn` para 1, mas ele termina o seu processo e precisar retornar para região crítica, mas está impedido.
:::
::::

## Exclusão mútua com espera ocupada

\

### Solução de Peterson

Antes de usar as variáveis compartilhadas (isto é, antes de entrar na região crítica), cada processo chama `enter_region` com seu próprio número de processo, 0 ou 1, como parâmetro. Essa chamada fará que ele espere, se necessário, até que seja seguro entrar. Após haver terminado com as variáveis compartilhadas, o processo chama `leave_region` para indicar que ele terminou e para permitir que outros processos entrem, se assim desejarem.

## Exclusão mútua com espera ocupada

\

### Solução de Peterson

```{.python}
#!/usr/bin/env python
# -*- coding: utf-8 -*-

import threading
import time

cs = 0
flag_0 = False
flag_1 = False
turn = 0

def thread_0():
    global cs, flag_0, flag_1, turn

    flag_0 = True
    turn = 1
    while (flag_1 and turn == 1):
            continue

    for i in range(10):
        cs += 1
        print("Thread 0: cs =", cs)
        time.sleep(0.1)

    flag_0 = False

def thread_1():
    global cs, flag_0, flag_1, turn

    flag_1 = True
    turn = 0
    while (flag_0 and turn == 0):
        continue

    for i in range(10):
        cs += 1000
        print("Thread 1: cs =", cs)
        time.sleep(0.1)

    flag_1 = False

if __name__ == "__main__":
		t0 = threading.Thread(target=thread_0)
		t1 = threading.Thread(target=thread_1)
		t0.start()
		t1.start()

# Reference: https://www.aspires.cc/implementing-peterson-algorithm-with-python/
```

## Sistemas de Transmissão de Mensagens

\

A transmissão de mensagens fornece um mecanismo para permitir que os processos se comuniquem e sincronizem suas ações sem compartilhar o mesmo espaço de endereçamento. Isso é particularmente útil em um ambiente distribuído em que os processos em comunicação podem residir em diferentes computadores conectados por uma rede. Por exemplo, um programa de bate-papo na Internet poderia ser projetado de modo que os participantes se comuniquem uns com os outros trocando mensagens.

Um recurso de transmissão de mensagens fornece, pelo menos, duas operações:

- send(message)
- receive(message)

## Sistemas de Transmissão de Mensagens

\

### Sockets
Um socket é definido como uma [extremidade de comunicação]{.blue}. [Um par de processos comunicando-se por uma rede emprega um par de sockets — um para cada processo. Um socket é identificado por um endereço IP concatenado com um número de porta.]{.marked} Geralmente, os sockets usam uma arquitetura cliente-servidor. O servidor espera solicitações recebidas de clientes ouvindo em uma porta especificada. Uma vez que uma solicitação seja recebida, o servidor aceita uma conexão proveniente do socket do cliente para completá-la.

## Sisitemas de Transmissão de Mensagens

\

:::: columns
::: {.column}

```{.python filename="server.py"}
import socket


def run_server():
    # create a socket object
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    server_ip = "127.0.0.1"
    port = 8000

    # bind the socket to a specific address and port
    server.bind((server_ip, port))
    # listen for incoming connections
    server.listen(0)
    print(f"Listening on {server_ip}:{port}")

    # accept incoming connections
    client_socket, client_address = server.accept()
    print(f"Accepted connection from {client_address[0]}:{client_address[1]}")

    # receive data from the client
    while True:
        request = client_socket.recv(1024)
        request = request.decode("utf-8") # convert bytes to string
        
        # if we receive "close" from the client, then we break
        # out of the loop and close the conneciton
        if request.lower() == "close":
            # send response to the client which acknowledges that the
            # connection should be closed and break out of the loop
            client_socket.send("closed".encode("utf-8"))
            break

        print(f"Received: {request}")

        response = "accepted".encode("utf-8") # convert string to bytes
        # convert and send accept response to the client
        client_socket.send(response)

    # close connection socket with the client
    client_socket.close()
    print("Connection to client closed")
    # close server socket
    server.close()


run_server()

```
:::
::: {.column}

```{.python filename="client.py"}
import socket


def run_client():
    # create a socket object
    client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    server_ip = "127.0.0.1"  # replace with the server's IP address
    server_port = 8000  # replace with the server's port number
    # establish connection with server
    client.connect((server_ip, server_port))

    while True:
        # input message and send it to the server
        msg = input("Enter message: ")
        client.send(msg.encode("utf-8")[:1024])

        # receive message from the server
        response = client.recv(1024)
        response = response.decode("utf-8")

        # if server sent us "closed" in the payload, we break out of the loop and close our socket
        if response.lower() == "closed":
            break

        print(f"Received: {response}")

    # close client socket (connection to the server)
    client.close()
    print("Connection to server closed")

run_client()

```
:::
::::

\

Exemplo extraído [daqui](https://www.datacamp.com/tutorial/a-complete-guide-to-socket-programming-in-python)

# Threads

\

> *Cada [processo]{.blue} tem um espaço de endereçamento e um único thread de controle. Na realidade, essa é quase a definição de um [processo]{.blue}. Não obstante isso, em muitas situações, é desejável ter múltiplos threads de controle no mesmo espaço de endereçamento executando em quase paralelo, como se eles fossem (quase) processos separados (exceto pelo espaço de endereçamento compartilhado).*

## Threads, miniprocessos

\

> *Por que alguém iria querer ter um tipo de processo dentro de um processo?* Na realidade, há várias razões para a existência desses miniprocessos, chamados [threads]{.blue}

:::: columns
::: {.column width="25%" .fragment}
A capacidade para as [entidades]{.blue} em paralelo [compartilharem um espaço de endereçamento e todos os seus dados entre si.]{.marked}
:::
::: {.column width="25%" .fragment}
[São mais leves do que os processos,]{.marked} eles são mais fáceis (isto é, mais rápidos) para criar e destruir do que os processos.
:::
::: {.column width="25%" .fragment}
Quando há uma computação substancial e também E/S substancial, contar com [threads permite que essas atividades se sobreponham]{.marked}.
:::
::: {.column width="25%" .fragment}
[Threads]{.blue} são úteis em sistemas com múltiplas CPUs, onde o [paralelismo real]{.marked} é possível.
:::
::::

## Um processador de texto com três threads

\

:::: columns
::: {.column}
[Um thread interage com o usuário]{.marked} e o [outro lida com a reformatação em segundo plano]{.marked}. *Tão logo a frase é apagada da página 1, o thread interativo diz ao de reformatação para reformatar o livro inteiro*. Enquanto isso, o thread interativo continua a ouvir o teclado e o mouse e responde a comandos simples como rolar a página 1 enquanto o outro thread está trabalhando com afinco no segundo plano. [Um terceiro thread pode fazer backups de disco sem interferir nos outros dois.]{.marked}
:::
::: {.column}
![](images/tanenbaum-02-07.png)
:::
::::

## Um processador de texto com três threads

\

> *Deve ficar claro que ter três processos em separado não funcionaria aqui, pois todos os três threads precisam operar no documento. [Ao existirem três threads em vez de três processos, eles compartilham de uma memória comum.]{.marked}*

## O modelo de thread clássico

\

:::: columns
::: {.column}
a. vemos três processos tradicionais. Cada processo tem seu próprio espaço de endereçamento e um único thread de controle. [Cada um deles opera em um espaço de endereçamento diferente.]{.marked}
b. vemos um único processo com três threads de controle. Embora em ambos os casos tenhamos três threads. [Todos os três compartilham o mesmo espaço de endereçamento.]{.marked}
:::
::: {.column}
![](images/tanenbaum-02-11.png)

> *Todo thread pode acessar todo espaço de endereçamento de memória dentro do espaço de endereçamento do processo, [um thread pode ler, escrever, ou mesmo apagar a pilha de outro thread.]{.marked} Não há proteção, porque (1) é impossível e (2) não seria necessário.*

:::
::::

## Threads POSIX

\

:::: columns
::: {.column width="33%" .fragment}
Para possibilitar que se escrevam programas com threads portáteis, [o IEEE definiu um padrão para threads]{.marked} no padrão IEEE 1003.1c. O pacote de threads que ele define é chamado [Pthreads]{.blue}.
:::
::: {.column width="33%" .fragment}
Todos os threads têm determinadas propriedades. Cada um tem um identificador, um conjunto de registradores (incluindo o contador de programa), e um conjunto de atributos, que são armazenados em uma estrutura.
:::
::: {.column width="33%" .fragment}

Algumas das chamadas de função do Pthreads:

![](images/tanenbaum-02-14.png)
:::
::::

## Executando Threads

\

```{.python filename="multiple_threads.py" code-line-numbers="|9|12-15|22-27|29-32"}

"""
Executando Múltiplas Threads

https://realpython.com/intro-to-python-threading/
"""

import logging
import threading
import time

def thread_function(name):
    logging.info("Thread %s: starting, ID: %s", name, threading.get_native_id())
    time.sleep(2)
    logging.info("Thread %s: finishing", name)

if __name__ == "__main__":
    format = "%(asctime)s: %(message)s"
    logging.basicConfig(format=format, level=logging.INFO,
                        datefmt="%H:%M:%S")

    threads = list()
    for index in range(3):
        logging.info("Main    : create and start thread %d.", index)
        x = threading.Thread(target=thread_function, args=(index,))
        threads.append(x)
        x.start()

    for index, thread in enumerate(threads):
        logging.info("Main    : before joining thread %d.", index)
        thread.join()
        logging.info("Main    : thread %d done", index)
```

## Convertendo de um thread para multithread

### Conflitos entre threads sobre o uso de uma variável global

\

:::: columns
::: {.column .fragment}
Conflitos entre threads sobre o uso de uma variável
global.
![](images/tanenbaum-02-19.png){width="90%"}
:::
::: {.column .fragment}
Threads podem ter variáveis globais individuais.

![](images/tanenbaum-02-20.png){width="50%"}
:::
::::

# Scheduling da CPU

> *O scheduling da CPU é a base dos sistemas operacionais multiprogramados. Alternando a CPU entre os processos, o sistema operacional pode tornar o computador mais produtivo.*

## Ciclo de Picos de CPU e I/O



:::: columns
::: {.column}
O sucesso do scheduling da CPU depende de uma propriedade observada nos processos: a execução de processos consiste em um ciclo de [execução da CPU e espera por I/O.]{.marked} Os processos se alternam entre esses dois estados. A execução do processo começa com um pico de CPU. Esse é seguido por um pico de I/O, que é seguido por outro pico de CPU e, então, outro pico de I/O, e assim por diante. Eventualmente, o último pico de CPU termina com o sistema solicitando o encerramento da execução
:::
::: {.column}

<center>
![](images/silberschatz-06-01.png){width="45%"}
</center>
<center>
![](images/silberschatz-06-02.png){width="50%"}
</center>

:::
::::

## Scheduler da CPU

\

Sempre que a CPU se torna ociosa, o sistema operacional deve selecionar um dos processos na fila de prontos para ser executado. O processo de seleção é realizado pelo scheduler de curto prazo, ou scheduler da CPU. O scheduler seleciona um processo entre os processos na memória que estão prontos para execução e aloca a CPU a esse processo.

## Scheduling com Preempção (interrupção forçada de um processo)

\

Decisões de scheduling da CPU podem ser tomadas sob as seguintes circunstâncias:

1. Quando um processo passa do estado de execução para o estado de espera [por exemplo, como resultado de uma solicitação de I/O ou de uma invocação a `wait` para o encerramento de um processo-filho]{.marked}
2. Quando um processo passa do estado de execução para o estado de pronto (por exemplo, quando ocorre uma interrupção)
3. Quando um processo passa do estado de espera para o estado de pronto (por exemplo, na conclusão de I/O)
4. Quando um processo termina


## Scheduling com Preempção

\

Nas situações 1 e 4, não há alternativa no que diz respeito ao scheduling. Um novo processo (se existir um na fila de prontos) deve ser selecionado para execução. Há uma alternativa, no entanto, nas situações 2 e 3.

\ 

Quando o scheduling ocorre apenas sob as circunstâncias 1 e 4, dizemos que o esquema de scheduling é sem preempção ou cooperativo. Caso contrário, ele tem preempção.

## Despachante

\

Outro componente envolvido na função de scheduling da CPU é o [despachante]{.blue}. O despachante [é o módulo que passa o controle da CPU ao processo selecionado pelo scheduler de curto prazo]{.marked}. Essa função envolve o seguinte:

- Mudança de contexto
- Mudança para a modalidade de usuário
- Salto para a locação apropriada no programa do usuário para que ele seja reiniciado.

\

O tempo que o despachante leva para interromper um processo e iniciar a execução de outro é conhecido como [latência do despacho]{.blue}.

## Critérios de Scheduling {.smaller}

\

Diferentes algoritmos de scheduling da CPU têm diferentes propriedades, e a escolha de um algoritmo específico pode favorecer uma classe de processos em vez de outra. Seguem alguns critérios para comparação de algorítmos:

:::: columns
::: {.column width="25%"}
[Utilização da CPU.]{.blue} Queremos manter a CPU tão ocupada quanto possível. [Conceitualmente, a utilização da CPU pode variar de 0 a 100%.]{.marked} Em um sistema real, ela deve variar de 40% (para um sistema pouco carregado) a 90% (para um sistema pesadamente carregado).
:::
::: {.column width="25%"}
[Throughput.]{.blue} Se a CPU está ocupada executando processos, trabalho está sendo realizado. [Uma medida de trabalho é o número de processos que são concluídos por unidade de tempo, chamado throughput.]{.marked} Para processos longos, essa taxa pode ser de um processo por hora; para transações curtas, ela pode ser de dez processos por segundo.
:::
::: {.column width="25%"}
[Tempo de turnaround.]{.blue} Do ponto de vista de um processo específico, o critério importante é quanto tempo ele leva para ser executado. [O intervalo entre o momento em que o processo é submetido e o momento de sua conclusão é o tempo de turnaround.]{.marked} O tempo de turnaround é a soma dos períodos gastos em espera para entrar na memória, em espera na fila de prontos, em execução na CPU, e executando I/O.
:::
::: {.column width="25%"}
[Tempo de espera.]{.blue} O algoritmo de scheduling da CPU não afeta o período de tempo durante o qual um processo é executado ou faz I/O. [Ele afeta somente o período de tempo que um processo gasta esperando na fila de prontos.]{.marked} O tempo de espera é a soma dos períodos gastos em espera na fila de prontos.
:::
::::

## Algoritmos de Scheduling

\

### Scheduling "Primeiro-a-Chegar, Primeiro-a-Ser-Atendido"

O algoritmo mais simples de scheduling da CPU é o algoritmo "primeiro-a-chegar, primeiro-a-ser-atendido" (FCFS – first-come, first-served). 
- Nesse esquema, o processo que solicita a CPU primeiro é o primeiro a usá-la. 
- Quando um processo entra na fila de prontos, seu PCB é conectado na cauda da fila. Quando a CPU está livre, ela é alocada ao processo na cabeça da fila.
- O lado negativo é que o tempo médio de espera na política FCFS geralmente é bem longo.

## Algoritmos de Scheduling

\

### Scheduling Menor-Job-Primeiro

Esse algoritmo associa a cada processo a duração do próximo pico de CPU do processo. Quando a CPU está disponível, ela é atribuída ao processo que tem o próximo pico de CPU mais curto

## Algoritmos de Scheduling

\

### Scheduling por Prioridades

Uma prioridade é associada a cada processo, e a CPU é alocada ao processo com a prioridade mais alta. Processos com prioridades iguais são organizados no schedule em ordem FCFS. O algoritmo SJF é simplesmente um algoritmo por prioridades em que a prioridade (p) é o inverso do próximo pico de CPU (previsto). Quanto maior o pico de CPU, menor a prioridade, e vice-versa.

## Algoritmos de Scheduling

\

### Scheduling Round-Robin

O scheduler da CPU seleciona o primeiro processo da fila de prontos, define um timer com interrupção após 1 quantum de tempo e despacha o processo.

Portanto, uma entre duas coisas ocorrerá. O processo pode ter um pico de CPU menor do que 1 quantum de tempo. Nesse caso, o próprio processo liberará a CPU voluntariamente. O scheduler passará então para o próximo processo na fila de prontos. Se o pico de CPU do processo em execução corrente for maior do que 1 quantum de tempo, o timer será desligado e causará uma interrupção para o sistema operacional. Uma mudança de contexto será executada e o processo será inserido na cauda da fila de prontos. O scheduler da CPU selecionará então o próximo processo na fila de prontos.

# Gerenciamento de memória

## Gerenciamento de memória

\

> *O que todo programador gostaria é de uma memória privada, infinitamente grande e rápida, que fosse não volátil também, isto é, não perdesse seus conteúdos quando faltasse energia elétrica. Aproveitando o ensejo, por que não torná-la barata, também? Infelizmente, a tecnologia ainda não produz essas memórias no momento.*

## Hierarquia de memória

\

Ao longo dos anos, as pessoas descobriram o conceito de [hierarquia de memórias]{.blue}, em que os computadores têm alguns megabytes de memória cache volátil, cara e muito rápida, alguns gigabytes de memória principal volátil de velocidade e custo médios, e alguns terabytes de armazenamento em disco em estado sólido ou magnético não volátil, barato e lento, sem mencionar o armazenamento removível, com DVDs e dispositivos USB. [É função do sistema operacional abstrair essa hierarquia em um modelo útil e então gerenciar a abstração.]{.marked}

*A parte do sistema operacional que gerencia (parte da) hierarquia de memórias é chamada de gerenciador de memória.*

## A noção de um espaço de endereçamento

\

Dois problemas têm de ser solucionados para permitir que múltiplas aplicações estejam na memória ao mesmo tempo sem interferir umas com as outras: [proteção e realocação.]{.marked}

\

Uma solução foi inventar uma nova abstração para a memória: o espaço de endereçamento. Da mesma forma que o conceito de processo cria uma espécie de CPU abstrata para executar os programas, [o espaço de endereçamento cria uma espécie de memória abstrata para abrigá-los.]{.marked} [Um espaço de endereçamento é o conjunto de endereços que um processo pode usar para endereçar a memória.]{.blue} [Cada processo tem seu próprio espaço de endereçamento, independente daqueles pertencentes a outros processos]{.marked} (exceto em algumas circunstâncias especiais onde os processos querem compartilhar seus espaços de endereçamento).

## Registradores base e registradores limite

\

:::: columns
::: {.column width="33%"}
Quando esses registradores são usados, os programas são carregados em posições de memória consecutivas sempre que haja espaço e sem realocação durante o carregamento. [Quando um processo é executado, o registrador base é carregado com o endereço físico onde seu programa começa na memória e o registrador limite é carregado com o comprimento do programa.]{.marked}
:::
::: {.column width="33%"}
Usar registradores base e limite é uma maneira fácil de dar a cada processo seu próprio espaço de endereçamento privado, pois cada endereço de memória gerado automaticamente tem o conteúdo do registrador base adicionado a ele antes de ser enviado para a memória.
:::
::: {.column width="33%"}
Desvantagem:  necessidade de realizar uma adição e uma comparação em cada referência de memória.
:::
::::

## Registradores base e registradores limite

\

:::: columns
::: {.column}
<center>
![(a) Um programa de 16 KB. (b) Outro programa de 16 KB. (c) Os dois programas carregados consecutivamente na memória.](images/tanenbaum-03-02.png){width="85%"}
</center>

:::

::: {.column}
<center>
![Registradores base (endereço físico onde seu programa começa) ou limite (comprimento do programa) podem ser usados para dar a cada processo um espaço de endereçamento em separado.](images/tanenbaum-03-03.png){width="65%"}
</center>

:::
::::

## Troca de processos (Swapping) 

\

:::: columns
::: {.column width="33%"}
Estratégia simples para lidar com a sobrecarga de memória que consiste em trazer cada processo em sua totalidade, executá-lo por um tempo e então colocá-lo de volta no disco. 
:::
::: {.column width="33%"}
Processos ociosos estão armazenados em disco em sua maior parte, portanto não ocupam qualquer memória quando não estão sendo executados. 
:::
::: {.column width="33%"}
Quando as trocas de processos criam múltiplos espaços na memória, é possível combiná-los em um grande espaço movendo todos os processos para baixo, o máximo possível. Essa técnica é conhecida como *compactação de memória*.
:::
::::

## Troca de processos (Swapping) 

\

Mudanças na alocação de memória à medida que processos entram nela e saem dela. As regiões sombreadas são regiões não utilizadas da memória:

\

<center>
![](images/tanenbaum-03-04.png)
</center>


## Quanta memória deve ser alocada para um processo quando ele é criado ou trocado? {.smaller}

:::: columns
::: {.column width="60%"}
- Se os processos são criados com um tamanho fixo que nunca muda, então a alocação é simples: [o sistema operacional aloca exatamente o que é necessário, nem mais nem menos]{.marked}. No entanto, um problema ocorre sempre que um processo tenta crescer. 
- Se houver um espaço adjacente ao processo, ele poderá ser alocado e o processo [será autorizado a crescer naquele espaço]{.marked}. 
- Por outro lado, se o processo for adjacente a outro, [aquele que cresce terá de ser movido para um espaço na memória grande o suficiente]{.marked} para ele, ou um ou mais processos terão de ser trocados para criar um espaço grande o suficiente. 
- Se um processo não puder crescer em memória e a área de troca no disco estiver cheia, [ele terá de ser suspenso até que algum espaço seja liberado]{.marked} (ou ele pode ser morto).
- [Se o esperado for que a maioria dos processos cresça à medida que são executados, provavelmente seja uma boa ideia alocar um pouco de memória extra sempre que um processo for trocado ou movido]{.marked}, para reduzir a sobrecarga associada com a troca e movimentação dos processos que não cabem mais em sua memória alocada. 
:::
::: {.column width="30%"}
<center>
![(a) Alocação de espaço para um segmento de dados em expansão. (b) Alocação de espaço para uma pilha e um segmento de dados em expansão.](images/tanenbaum-03-05.png){width="120%"}
</center>

:::
::::

## Gerenciamento de memória com mapas de bits ou listas encadeadas

\

<center>
![(a) Uma parte da memória com cinco processos e três espaços. As marcas indicam as unidades de alocação de memória. As regiões sombreadas (0 no mapa de bits) estão livres. (b) Mapa de bits correspondente. (c) A mesma informação como lista.](images/tanenbaum-03-06.png){width="80%"}
</center>

## Gerenciamento de memória com listas encadeadas

Uma maneira de controlar o uso da memória é manter uma lista encadeada de espaços livres e de segmentos de memória alocados, onde um segmento contém um processo ou é um espaço vazio entre dois processos.

### Algoritmos:
- [first fit]{.blue} (procura fazer a menor busca possível);
- [next fit]{.blue} (uma pequena variação do first fit, exceto por memorizar a posição que se encontra um espaço livre adequado sempre que o encontra);
- [best fit]{.blue} (faz uma busca em toda a lista, do início ao fim, e escolhe o 	menor espaço livre que seja adequado); 
- [worst fit]{.blue} (sempre escolhe o maior espaço livre);
- [quick fit]{.blue} (mantém listas em separado para alguns dos tamanhos mais 	comuns solicitados).

## Memória virtual

\

> *Apesar de os tamanhos das memórias aumentarem depressa, os tamanhos dos softwares estão crescendo muito mais rapidamente.* 

\

Como consequência desses desenvolvimentos, *há uma necessidade de executar programas que são grandes demais para se encaixar na memória e há certamente uma necessidade de ter sistemas que possam dar suporte a múltiplos programas executando em simultâneo*, [cada um deles encaixando-se na memória, mas com todos coletivamente excedendo-a.]{.marked}

## Memória virtual

\

:::: columns
::: {.column width="33%"}
> *Método encontrado para passar todo o programa para o computador.*
:::
::: {.column width="33%"}
A ideia básica é que cada programa tem seu próprio espaço de endereçamento, o qual é dividido em blocos chamados de páginas.
:::
::: {.column width="33%"}
Funciona bem em um sistema de multiprogramação, com pedaços e partes de muitos programas na memória simultaneamente. [Enquanto um programa está esperando que partes de si mesmo sejam lidas, a CPU pode ser dada para outro processo.]{.marked}
:::
::::

## Paginação {.smaller}

\

> *Paginação é um esquema de gerenciamento de memória pelo qual um computador armazena e recupera dados de um armazenamento secundário para uso na memória principal*

:::: columns
::: {.column}
- O espaço de endereçamento virtual consiste em unidades de tamanho fixo chamadas de [páginas]{.blue}.
- As unidades correspondentes na memória física são chamadas de [quadros de página]{.blue}.
- [Transferências entre a memória RAM e o disco]{.marked} são sempre em páginas inteiras.
- A paginação é implementada normalmente por unidades dedicadas de hardware integradas nos processadores [(Memory Management Unit)]{.blue}. O MMU que irá criar os endereços
:::
::: {.column}
![A relação entre endereços virtuais e endereços de memória física é dada pela tabela de páginas. Cada página começa com um múltiplo de 4096 e termina 4095 endereços acima; assim, 4K a 8K na verdade significa 4096-8191 e 8K a 12K significa 8192-12287.](images/tanenbaum-03-09.png){width="60%"}
:::
::::

## Tabelas de página

\

> *O objetivo da tabela de páginas é mapear as páginas virtuais em quadros de páginas.*

- Estrutura de uma entrada da tabela de páginas: 

<center>
![](images/tanenbaum-03-11.png){width="50%"}
</center>

- O campo mais importante é o Número do quadro de página. Afinal, a meta do mapeamento de páginas é localizar esse valor.

## TLB (Translation Lookaside Buffers) ou memória Associativa

\

> Pequeno dispositivo de hardware para mapear endereços virtuais para endereços físicos sem ter de passar pela tabela de páginas.

<center>
![](images/tanenbaum-03-12.png){width="40%"}
</center>

## Substituição de páginas {.smaller}

\

:::: columns
::: {.column}
> [Quando ocorre uma falta de página, o sistema operacional tem de escolher uma página para remover da memória]{.marked} a fim de abrir espaço para a que está chegando.

- Se a página a ser removida foi modificada enquanto estava na memória, ela precisa ser reescrita para o disco a fim de atualizar a cópia em disco.

- Se, no entanto, ela não tiver sido modificada (por exemplo, ela contém uma página de código), a cópia em disco já está atualizada, portanto não é preciso reescrevê-la.
Assim a página a ser lida simplesmente sobrescreve a página que está sendo removida. 
:::
::: {.column}
- Embora seja possível escolher uma página ao acaso para ser descartada a cada falta de página, [o desempenho do sistema será muito melhor se for escolhida uma página que não é intensamente usada.]{.marked}
- Se uma página intensamente usada for removida, ela provavelmente terá de ser trazida logo de volta, resultando em um custo extra. Muitos trabalhos, tanto teóricos quanto experimentais, têm sido feitos sobre o assunto dos algoritmos de substituição de páginas.
:::
::::

# Sistemas de Arquivos

## Sistemas de Arquivos

\

> Arquivos são gerenciados pelo sistema operacional. Como um todo, aquela parte do sistema operacional lidando com arquivos é conhecida como sistema de arquivos. 

\

*Um arquivo fornece uma maneira para armazenar informações sobre o disco e lê-las depois. Isso deve ser feito de tal modo que isole o usuário dos detalhes de como e onde as informações estão armazenadas.*

## Nomeação de Arquivos {.smaller}

\

> Quando um processo cria um arquivo, ele lhe dá um nome. Quando o processo é concluído, o arquivo continua a existir e pode ser acessado por outros processos usando o seu nome.

:::: columns
::: {.column width="25%"}
As regras para a nomeação de arquivos variam de sistema para sistema, mas todos os sistemas operacionais atuais permitem cadeias de uma a oito letras como nomes de arquivos legais. Dígitos e caracteres especiais também são frequentemente permitidos.
:::
::: {.column width="25%"}
Alguns sistemas de arquivos distinguem entre letras maiúsculas e minúsculas. O UNIX faz essa distinção; o MS-DOS, não. 
:::
::: {.column width="25%"}
Um sistema UNIX pode ter todos os arquivos a seguir como três arquivos distintos: maria, Maria e MARIA. No MS-DOS, todos esses nomes referem-se ao mesmo arquivo.
:::
::: {.column width="25%"}
Muitos sistemas operacionais aceitam nomes de arquivos de duas partes, com as partes separadas por um ponto, como em prog.c. A parte que vem depois do ponto é a extensão do arquivo.
:::
::::

## Tipos de arquivos

\

> O UNIX e o Windows, por exemplo, apresentam arquivos regulares e diretórios. O UNIX também tem arquivos especiais de caracteres e blocos. 

- Arquivos regulares são aqueles que contêm informações do usuário. 
- Diretórios são arquivos do sistema para manter a estrutura do sistema de arquivos.
- Arquivos especiais de caracteres são relacionados com entrada/saída e usados para modelar dispositivos de E/S seriais como terminais, impressoras e redes.
- Arquivos especiais de blocos são usados para modelar discos.

## Tipos de arquivos

\

> Arquivos regulares geralmente são arquivos ASCII ou arquivos binários. Arquivos ASCII consistem de linhas de texto.

- [ASCII]{.blue}: Código Padrão Americano para o Intercâmbio de Informação é um sistema de representação de letras, algarismos e sinais de pontuação e de controle
- A grande vantagem dos arquivos ASCII é que eles podem ser exibidos e impressos como são e editados com qualquer editor de texto. Além disso, se grandes números de programas usam arquivos ASCII para entrada e saída, é fácil conectar a saída de um programa com a entrada de outro, como em pipelines do interpretador de comandos (shell)
- Outros arquivos são binários, o que apenas significa que eles não são arquivos ASCII. Listá-los em uma impressora resultaria em algo completamente incompreensível. Em geral, eles têm alguma estrutura interna conhecida pelos programas que os usam.

## Atributos de arquivos

\

:::: columns
::: {.column width="40%"}
Todo arquivo possui um nome e sua data. Além disso, os sistemas operacionais associam outras informações com os arquivos, como data e horário em que foi modificado pela última vez, e tamanho do arquivo. Esses itens extras são atributos do arquivo ou metadados.
:::
::: {.column width="60%"}
<center>
![Alguns possíveis atributos de arquivos](images/tanenbaum-04-04.png){width="70%"}
</center>
:::
::::

## Operações com arquivos

\

1. Create `touch` ou `echo 'algum texto' > arquivo.txt`
2. Delete `rm arquivo.txt`
3. Open
4. Close
5. Read
6. Write
7. Append `echo 'algum outro texto' >> arquivo.txt`
8. Get attributes
9. Set attributes `chmod 640 arquivo.txt`
10. Rename `mv antigo novo`

## Diretórios

\

> Para controlar os arquivos, sistemas de arquivos normalmente têm diretórios ou pastas, que são em si arquivos. Nesta seção discutiremos diretórios, sua organização, suas propriedades e as operações que podem ser realizadas por eles.

\

A capacidade dos usuários de criarem um número arbitrário de subdiretórios proporciona uma ferramenta de estruturação poderosa para eles organizarem o seu trabalho. Por essa razão, quase todos os sistemas de arquivos modernos são organizados dessa maneira.

## Operações com diretórios

\

1. Create `mkdir pasta`
2. Delete `rmdir pasta`
3. Opendir
4. Closedir
5. Readdir
6. Rename `mv antigo novo`
7. Link `link arquivo nome_link`
8. Unlink `unlink nome_link`

## Gerenciamento e otimização de sistemas de arquivos

\

> O gerenciamento de espaço de disco é uma preocupação importante para os projetistas de sistemas de arquivos. [Duas estratégias gerais são possíveis para armazenar um arquivo de n bytes: ou são alocados n bytes consecutivos de espaço, ou o arquivo é dividido em uma série de blocos]{.marked} (não necessariamente) contíguos. 

\

Como vimos, [armazenar um arquivo como uma sequência contígua de bytes tem o problema óbvio de que se um arquivo crescer, ele talvez tenha de ser movido dentro do disco. O mesmo problema ocorre para segmentos na memória, exceto que mover um segmento na memória é uma operação relativamente rápida em comparação com mover um arquivo]{.marked} de uma posição no disco para outra.

## Gerenciamento e otimização de sistemas de arquivos

\

*Feita a opção de armazenar arquivos em blocos de tamanho fixo, devemos decidir qual tamanho o bloco terá.*

\

- [Ter um tamanho de bloco grande]{.marked} significa que todos os arquivos, mesmo um de 1 byte, ocuparão um bloco inteiro. Também significa que arquivos pequenos desperdiçam uma grande quantidade de espaço de disco.
- Por outro lado, [um tamanho de bloco pequeno]{.marked} significa que a maioria dos arquivos ocupará múltiplos blocos e, desse modo, precisará de múltiplas buscas e atrasos rotacionais para lê-los, reduzindo o desempenho. 
- [Então, se a unidade de alocação for grande demais, desperdiçamos espaço; se ela for pequena demais, desperdiçamos tempo.]{.marked}

## Monitoramento dos blocos livres

\

:::: columns
::: {.column width="30%"} 
Uma lista encadeada de blocos de disco, com cada bloco contendo tantos números de blocos livres de disco quantos couberem nele (a).
:::
::: {.column width="70%"}
<center>
![(a) Armazenamento da lista de blocos livres em uma lista encadeada. (b) Um mapa de bits.](images/tanenbaum-04-22.png){width="80%"}
</center>
:::
::::

# Sistemas de I/O

## Sistemas de I/O

\

> *As duas tarefas principais de um computador são I/O e processamento. Em muitos casos, a principal tarefa é o I/O, e o processamento é meramente incidental. Por exemplo, quando navegamos em uma página da web ou editamos um arquivo, nosso interesse imediato é ler ou dar entrada em alguma informação, e não computar uma resposta.*

## Hardware de I/O

\

:::: columns
::: {.column}
Os computadores operam muitos tipos de dispositivos. [A maioria enquadra-se nas categorias gerais de dispositivos de armazenamento (discos, fitas), dispositivos de transmissão (conexões de rede, Bluetooth) e dispositivos de interface humana (tela, teclado, mouse, entrada e saída de áudio).]{.marked} *Outros dispositivos são mais especializados, como os envolvidos na pilotagem de um jato.*
:::
::: {.column}
Nessas aeronaves, uma pessoa fornece entradas para o computador de voo por meio de um joystick e de pedais, e o computador envia comandos de saída que fazem os motores acionarem os lemes, os flaps e o combustível para as máquinas. *Apesar da incrível variedade de dispositivos de I/O, no entanto, precisamos apenas de alguns conceitos para entender como eles são conectados e como o software pode controlar o hardware.*
:::
::::

## Hardware de I/O

\

:::: columns
::: {.column}
Um dispositivo comunica-se com um sistema de computação enviando sinais por um cabo ou até mesmo através do ar. O dispositivo se comunica com a máquina por um ponto de conexão, ou porta — por exemplo, uma porta serial. *Quando os dispositivos compartilham um conjunto de fios, a conexão é chamada de [bus]{.blue}*. [Um bus é um conjunto de fios e um protocolo rigidamente definido que especifica um conjunto de mensagens que podem ser enviadas nos fios.]{.marked}
:::
::: {.column}
Em termos de eletrônica, as mensagens são transmitidas por padrões de voltagens elétricas aplicados aos fios em intervalos de tempo definidos. Quando o dispositivo A tem um cabo que se conecta ao dispositivo B, o dispositivo B tem um cabo que se conecta ao dispositivo C, e o dispositivo C se conecta a uma porta no computador, essa configuração é chamada de cadeia margarida. Uma cadeia margarida opera usualmente como um bus.
:::
::::

## Hardware de I/O

\

:::: columns
::: {.column}
Os buses são amplamente usados na arquitetura de computadores e variam em seus métodos de sinalização, em velocidade, no throughput (número de processos executados por unidade de tempo) e nos métodos de conexão. Uma estrutura típica de bus de PC é mostrada na figura.

\

<center>
bus=barramento
</center>
:::
::: {.column}
<center>
![Uma estrutura típica de bus de PC.](images/silberschatz-13-01.png){width="90%"}
</center>
:::
::::

## Hardware de I/O

\

*Como o processador pode fornecer comandos e dados a um controlador para realizar uma transferência de I/O?*

:::: columns
::: {.column width="33%"}
Uma resposta resumida é que o controlador tem um ou mais registradores para dados e sinais de controle. O processador comunica-se com o controlador lendo e gravando padrões de bits nos seus registradores. 
:::
::: {.column width="33%"}
Uma forma pela qual essa comunicação pode ocorrer é através do uso de instruções de I/O especiais que determinam a transferência de um byte ou palavra para um endereço de porta de I/O.
:::
::: {.column width="33%"}
A instrução de I/O dispara linhas de bus para selecionar o dispositivo apropriado e mover bits para dentro e para fora de um registrador de dispositivo. 
:::
::::

## Hardware de I/O

\

*Alternativamente, o controlador do dispositivo pode suportar I/O mapeado para a memória.*

\

Nesse caso, os registradores de controle do dispositivo são mapeados para o espaço de endereçamento do processador. A CPU executa solicitações de I/O usando as instruções-padrão de transferência de dados para ler e gravar os registradores de controle de dispositivos em suas locações mapeadas na memória física.

## Interface de I/O da Aplicação

\

:::: columns
::: {.column}
A finalidade da camada do driver de dispositivos é ocultar, do subsistema de I/O do kernel, as diferenças entre controladores de dispositivos, de modo semelhante a como as chamadas de sistema de I/O encapsulam o comportamento de dispositivos em algumas classes genéricas que ocultam, dos aplicativos, as diferenças de hardware.
:::
::: {.column}
![Uma estrutura de I/O do kernel.](images/silberschatz-13-06.png)
:::
::::

\

Infelizmente para os fabricantes de hardware de dispositivos, cada tipo de sistema operacional tem seus próprios padrões para a interface dos drivers de dispositivos.

<!-- Configuração do Linux -->

# Instalação e Configuração do Linux

## [Instalação via WSL](https://learn.microsoft.com/pt-br/windows/wsl/install)

Abra o PowerShell e execute

```{.bash filename="PowerShell"}
wsl --install
```

Por padrão será instalada a distribuição Ubuntu.

\

Caso queira instalar uma outra distribuição adcione o argumento `-d` e o nome da distribuição

```{.bash filename="PowerShell"}
wsl --install -d <nome da distribuição>
```

## [Configuração do ambiente](https://learn.microsoft.com/pt-br/windows/wsl/setup/environment)

\

- Após a instalação será necessário definir um usuário e uma senha
- Caso você não seja o administrador da máquina, será necessária algumas configurações adicionais:

No PowerShell execute o comando para poder acessar o usuário `root`:

```{.bash filename="PowerShell"}
wsl --install -d <nome da distribuição> -u <nome do usuário>
```

Por exemplo caso tenha instalado o Debian, será `-d Debian`

- Adicionar o seu usuário no sudoers para ter acesso a alguns privilégios

No terminal do linux digitar o comando

```{.bash filename="$"}
usermod -aG sudo <nome do usuário>
```

## Instalando programas

\

Nas distribuições derivadas do Debian o gerenciador de pacotes é o `apt`

- Para instalar o programa `cmatrix`

```{.bash filename="$"}
sudo apt install cmatrix
```

Para executar escreva `cmatrix` no terminal

```{.bash filename="$"}
cmatrix
```

## Erros que podem surgir na instalação

\

Comandos que podem ser executados para solucionar erros de instalação

```{.bash}
sudo apt install <nome do pacote> --fix-missing
```

```{.bash}
sudo apt update
sudo apt --fix-broken install
sudo apt install <nome do pacote>
```

## Alguns programas úteis

\

- `neovim` editor de código
- `g++` compilador de código `c++`
- `tmux` permite que várias sessões de terminal sejam acessadas simultaneamente em uma única janela
- `wget` permite fazer download de conteúdos da web

Para instalar todos eles de uma vez

```{.bash filename="$"}
sudo apt install neovim g++ tmux wget
```

# Usando vi/vim/neovim

## Comandos básicos do neovim

\

- Para instalar: `sudo apt install neovim`
- Para iniciar digite `nvim`

<center>
![](images/nvim-01.png){width="50%"}
</center>

## Comandos básicos do neovim

\

Para iniciar no modo de `-- INSERÇÃO --` ou `-- INSERT --`, clique na letra `i`

<center>
![](images/nvim-02.png){width="50%"}
</center>

Assim será possível digitar

## Comandos básicos do neovim

\

[-- Após digitar, você deve sair do modo `-- INSERÇÃO --` clicando em `ESC`]{.fragment fragment-index=1}

[-- Para salvar o arquivo digite `:` e em seguida `w script.sh`]{.fragment fragment-index=2}

[-- Clicando na tecla `ENTER` o arquivo está salvo com o nome `script.sh`]{.fragment fragment-index=3}

[-- Para sair é só digitar `:`, depois `q` e então a tecla `ENTER`]{.fragment fragment-index=4}

::: {.fragment fragment-index=1}
<center>
![](images/nvim-03.png){.absolute top=450 left=500 width="40%"}
</center>

:::

::: {.fragment fragment-index=2}
<center>
![](images/nvim-04.png){.absolute top=450 left=500 width="40%"}
</center>

:::

::: {.fragment fragment-index=3}
<center>
![](images/nvim-05.png){.absolute top=450 left=500 width="40%"}
</center>

:::

::: {.fragment fragment-index=4}
<center>
![](images/nvim-06.png){.absolute top=450 left=500 width="40%"}
</center>

:::

## Comandos básicos do neovim

\

![](images/vim-graphical-cheat-sheet.webp)

# Usando tmux

## Comandos básicos do tmux

\

:::: columns
::: {.column width="60%"}
<center>
![](images/tmux-cheat-sheet.png)
</center>

:::
::: {.column width="40%"}
- Instalar `sudo apt install tmux` e para executar `tmux`
- Arquivo de configuração `.tmux.conf` pode ser alterado e salvo em `/home/usuario`
- Exemplo de um arquivo de configuração [aqui](https://gist.githubusercontent.com/th1460/200ee712919f1551340754630daf2c0c/raw/0766c12adefd5e4cf28295213986126db04b632a/.tmux.conf)
- O prefixo foi alterado para `ctrl + a`
- A divisão vertical `ctrl + b` e `-`; a divisão horizontal `ctrl + b` e `\`
:::
::::

## Comandos básicos do tmux

\

[-- Para dividir a janela horizontalmente com `ctrl + a \`]{.fragment fragment-index=1}

[-- Para dividir a janela verticalmente com `ctrl + a -`]{.fragment fragment-index=2}

[-- Para criar nova janela com `ctrl + a c`]{.fragment fragment-index=3}

::: {.fragment fragment-index=1}
<center>
![](images/tmux-01.png){.absolute top=390 left=400 width="50%"}
</center>

:::

::: {.fragment fragment-index=2}
<center>
![](images/tmux-02.png){.absolute top=390 left=400 width="50%"}
</center>

:::

::: {.fragment fragment-index=3}
<center>
![](images/tmux-03.png){.absolute top=390 left=400 width="50%"}
</center>

:::

# Containers (Docker)

> Um container do Docker é um ambiente de runtime com todos os componentes necessários, como código, dependências e bibliotecas, necessários para executar o código da aplicação sem usar dependências da máquina host.

\

Runtime: *A maioria das linguagens de programação possui algum tipo de sistema de tempo de execução que fornece um ambiente no qual os programas são executados.*

## [Como o Docker funciona?](https://www.redhat.com/pt-br/topics/containers/what-is-docker)

A tecnologia Docker usa o kernel do Linux e funcionalidades do kernel, como cGroups e namespaces, para segregar processos. Assim, eles podem ser executados de maneira independente. O objetivo dos containers é criar independência: a habilidade de executar diversos processos e apps separadamente para utilizar melhor a infraestrutura e, ao mesmo tempo, manter a segurança que você teria em sistemas separados.

- [cGroups](https://access.redhat.com/documentation/pt-br/red_hat_enterprise_linux/8/html/managing_monitoring_and_updating_the_kernel/using-control-groups-through-a-virtual-file-system_setting-limits-for-applications): Você pode usar control groups (cgroups) para estabelecer limites, priorizar ou controlar o acesso aos recursos de hardware para grupos de processos. Isto permite que você controle granularmente o uso de recursos de aplicações para utilizá-los de forma mais eficiente. 
- [namespaces](https://lwn.net/Articles/528078/): No contexto dos contêineres, isso significa que usuários e grupos podem ter privilégios para determinadas operações dentro do contêiner sem ter esses privilégios fora do contêiner. (Em outras palavras, o conjunto de capacidades de um processo para operações dentro de um namespace de usuário pode ser bem diferente de seu conjunto de capacidades no sistema host.)

## *Puxar* uma imagem de um registro

> Um registro (registry) de contêiner é um repositório — ou coleção de repositórios — usado para armazenar e acessar imagens de container.

\

Os registros de containeres economizam um tempo valioso dos desenvolvedores na criação e entrega de aplicativos nativos da nuvem, agindo como intermediários para o compartilhamento de imagens de contêineres entre sistemas.

```{.bash}
docker pull alpine
```

## Executar um container

Para processos interativos (como um shell), você deve usar os parâmetros `-i -t` juntos para alocar um `tty` (terminal) para o container.

```{.bash}
docker run -it alpine
```

Site oficial da distribuição Alpine Linux: <https://www.alpinelinux.org/>

- Gerenciador de pacotes (`apk`)
- Para instalar `apk add cmatrix`

## Imagens com programas já configurados

### Python com um Debian mínimo

Para puxar a imagem

```{.bash}
docker pull python:3.12.3-slim-bullseye
```

\

Para executar a imagem

```{.bash}
docker run -it python:3.12.3-slim-bullseye
```

\

Para abrir o shell deste container seguir estes passos

1. Executar o container: `docker run -it python:3.12.3-slim-bullseye`
2. Verificar qual o `ID` do container que está em execução: `docker container ls`
3. Executar o comando para acessar o terminal: `docker exec -it <CONTAINER ID> bash`

## Verificando o tamanho das imagens

\

```{.bash}
docker image ls
```

\

```
REPOSITORY                TAG                   IMAGE ID      CREATED       SIZE
docker.io/library/alpine  latest                442043f030d3  6 days ago    9.12 MB
docker.io/library/python  3.12.3-slim-bullseye  d8ed415581d3  7 weeks ago   127 MB
```

## Criação de um `Dockerfile`

\

> `Dockerfile` nada mais é do que um meio que utilizamos para criar nossas próprias imagens.

```{.bash filename="Dockerfile" code-line-numbers="1|2|3"}
FROM alpine # utilização de uma imagem base
RUN apk add cmatrix # execução de comandos na etapa de build
CMD cmatrix # execução de comandos na etapa de inicialização do container
```

Outros comandos

- `COPY src src` compiar uma pasta local de nome `src` para dentro da imagem
- A lista completa poderá ser visualizada aqui <https://docs.docker.com/reference/dockerfile/>

Usar o comando: `docker build -t alpine-new` para recriar a imagem a partir das alterações no `Dockerfile`



















